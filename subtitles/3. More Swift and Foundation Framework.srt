1
00:00:06,000 --> 00:00:09,060
Stanford University. >> Okay,
斯坦福大学

2
00:00:09,070 --> 00:00:13,740
well welcome to lecture number three of Stanford CS193P.
欢迎来到斯坦福 CS193P 课程第三讲

3
00:00:13,740 --> 00:00:17,410
This is spring quarter 2016. And today we
这是 2016 年春季

4
00:00:17,410 --> 00:00:22,140
are going to mostly talk about the layer under the UI.
今天我们主要会介绍UI层

5
00:00:22,150 --> 00:00:24,450
Okay, so we're gonna talk about Swift the language.
我们会讨论 Swift 这门语言

6
00:00:24,450 --> 00:00:26,950
We're gonna talk about this foundation framework that
我们将会讨论位于核心服务层顶部的 foundation 框架

7
00:00:26,950 --> 00:00:29,550
lives on top of Core services. So we're not going to be
所以我们不会讨论一整天非常多关于 UI 的内容

8
00:00:29,550 --> 00:00:32,920
talking about the UI very much at all today. I do have a demo
我有一个用演示作为结束

9
00:00:32,920 --> 00:00:36,490
towards the end. So I will finish off the slides and
我会完成这些幻灯片然后我们把这个演示做完

10
00:00:36,490 --> 00:00:40,090
then we'll do the demo to finish. Okay, all right, so
好的

11
00:00:40,100 --> 00:00:43,200
first thing I want to talk about is optional's,
首先我想介绍的是 optional

12
00:00:43,200 --> 00:00:46,030
by the way, everything I am talking about today is
顺便说下 我今天介绍的所有东西

13
00:00:46,040 --> 00:00:49,340
in your reading assignments. Okay, I'm just, the things I
都在你们的阅读作业里。好的

14
00:00:49,340 --> 00:00:52,040
am talking about today I want to emphasize. I mean these
我想强调我今天介绍的东西

15
00:00:52,040 --> 00:00:54,280
are things that you really really want to understand.
我的意思是这些东西你们真的真的需要理解

16
00:00:54,280 --> 00:00:56,880
So if you see me mention it today and then you're reading
如果你在你的阅读作业里读到我今天提到的东西

17
00:00:56,880 --> 00:00:59,950
it in the reading assignment, be sure to pay close attention
确保密切关注好吗？

18
00:00:59,950 --> 00:01:02,920
all right? So as we learned in the last lecture,
那在我们上节课学的内容中

19
00:01:02,920 --> 00:01:07,020
optional is just an enum, okay? It's a generic type kind
optional 就是一个 enum 是吧？它是一个有点像数组的泛型

20
00:01:07,020 --> 00:01:09,190
of like array. It's got this little angle bracket T,
它有个小尖括号 <T>

21
00:01:09,190 --> 00:01:11,530
which just means an Optional can be an Optional of any
这意味着 Optional 可以选择任何类型

22
00:01:11,530 --> 00:01:14,000
type. And we know that to be the case. We can have
并且我们知道的情况

23
00:01:14,000 --> 00:01:17,000
Optional strings or Optional even Optional optionals.
我们可以有可选字符串或者任何可选类型

24
00:01:17,000 --> 00:01:19,530
We can have any kind of Optional we want. And so
我们可以选择任何我们想要的 Optional

25
00:01:19,540 --> 00:01:22,400
it's an enum with two cases. The None case which is the not
所以这是一个有两种情况的 enum。

26
00:01:22,410 --> 00:01:25,710
set case and then the Some case, which is the set case.
None 情况是没有设置东西，其它情况是设置了一些东西的

27
00:01:25,710 --> 00:01:27,780
And in the Some case it has an associated value. And you
在一些情况下它有相关的值

28
00:01:27,780 --> 00:01:31,450
learned all about enums last time. So this, syntax should
你们最近学过的关于枚举的内容

29
00:01:31,450 --> 00:01:37,220
look completely, familiar to you. So let's look at some
所以这个语法对你们来说应该是完全熟悉的

30
00:01:37,220 --> 00:01:40,250
of the little question mark, exclamation point stuff. And
让我们来看看这些小问号，惊叹号

31
00:01:40,260 --> 00:01:43,060
what that means in terms of optional behind the scenes. So
在这些场景背后它们和 optional 的关系是什么

32
00:01:43,060 --> 00:01:47,060
if you had a constant x which was of type optional string,
如果你有一个常量 x 它的类型是 optionl 字符串

33
00:01:47,060 --> 00:01:48,460
right, string question mark.
对，字符串问号

34
00:01:48,470 --> 00:01:53,330
And I set it to nil, then that's the same as saying that
然后我把它设置为 nil ，这等同于是说 x = Optional<s>.None</s>

35
00:01:53,340 --> 00:01:58,310
x = Optional<s>.None, right? Obviously, and same</s>
对吗？显然， 的情况一样

36
00:01:58,310 --> 00:02:00,940
thing if I had an optional string that was set to hello,
如果我有一个可选字符串设置成 hello

37
00:02:00,940 --> 00:02:04,880
that'd be the same as x=Optional<s>.Some</s>
那就等于 x=Optional<s>.Some</s>

38
00:02:04,880 --> 00:02:07,150
with the associated value, hello. Okay,
关联的值是 hello。 好的

39
00:02:07,150 --> 00:02:10,690
everybody cool with that? And similarly, if I unwrap,
大家都觉得这很酷吧？类似的，假如我拆包

40
00:02:10,690 --> 00:02:15,120
if I said, var y=x unwrapped, that just means switch x,
如果我说，var y=x 拆包，那就意味着开关 x

41
00:02:15,130 --> 00:02:17,390
because we know that the way we unwrap Optionals and
因为我们知道我们那样子拆包 Optionals

42
00:02:17,390 --> 00:02:19,560
get their associated value is with switch, so
所以我会打开 x 并用开关得到相关的值

43
00:02:19,560 --> 00:02:22,400
I'm gonna switch on x. And in the case of Some, I'm gonna
在一些情况下，我会用 let 值

44
00:02:22,400 --> 00:02:25,670
do that let value thing so I can grab the associated value.
因为这样我可以抓取相关的值

45
00:02:25,670 --> 00:02:28,470
And then I'm just gonna set y equal to that value.
然后我要设置 y 等于那个值

46
00:02:28,470 --> 00:02:30,100
In the case None, I'm gonna crash.
在空的情况下，我的程序会 crash

47
00:02:30,110 --> 00:02:32,740
I'm gonna raise an exception, okay, because that's what
我要提出一个列外

48
00:02:32,740 --> 00:02:35,540
unwrapping an Optional that's not said is supposed to do,
因为拆包一个 Optional 不意味着它应该这么做

49
00:02:35,550 --> 00:02:40,450
it's supposed to crash, okay? And of course, in the case
它应该让程序奔溃。

50
00:02:40,450 --> 00:02:44,420
where I'm doing if let, then I'm just gonna switch on x,
如果我用 let 这么做，然后我去 switch x

51
00:02:44,420 --> 00:02:47,190
and I'm, the case of .Some, I'm gonna grab that y, and
在 .Some 情况下我用 y 拿出 x 的值

52
00:02:47,190 --> 00:02:49,720
then I'm just gonna put some code, whatever my code is in
然后就会执行我放在下面的代码
53
00:02:43,731 --> 00:02:46,899
there, and if let to happen there. And in the case None,
然而在 None 的情况下

53
00:02:52,900 --> 00:02:54,660
I just break out of the switch, I do nothing.
我会直接跳出 switch 什么都不做

54
00:02:54,660 --> 00:02:59,700
Okay, sound good? All right, so that's Optionals.
听起来不错？ 这就是 Optionals

55
00:02:59,700 --> 00:03:01,370
Hopefully Optional now should start feeling very,
希望现在开始对 Optional 的感觉好点了

56
00:03:01,370 --> 00:03:03,340
very comfortable to you cuz, as you found out,
在这些 API 里面

57
00:03:03,340 --> 00:03:07,640
it's everywhere in these, in the API. Now Optionals have
你会发现到处都有舒服的提示

58
00:03:07,640 --> 00:03:10,710
some more syntax, okay. That question mark and exclamation
现在 Optionl 有更多的语法了。你看见的那些问号和感叹号

59
00:03:10,710 --> 00:03:13,880
point stuff, as you're seeing, is just syntactic sugar.
都是语法糖

60
00:03:13,880 --> 00:03:16,720
It's just to make the, your typing it in easier and
这是为了让你写起来更舒服并且更好看

61
00:03:16,720 --> 00:03:20,590
look nicer. It has a little bit more syntactic sugar.
它还有更多的语法糖

62
00:03:20,590 --> 00:03:24,660
One thing is that Optionals can be chained. Okay, so
比如 OPtional 可以是链式的

63
00:03:24,660 --> 00:03:26,460
this is the case where, for example,
如同这个例子的情况

64
00:03:26,460 --> 00:03:29,530
in our calculator, we have the display, and
在我吗的计算器例子里，我们有显示，

65
00:03:29,530 --> 00:03:34,340
lets say we want to get the text out of the display. And
让我们把一些想要得到的文本显示出来

66
00:03:34,340 --> 00:03:38,070
then we want to send another message like hash value which,
然后我们想传递一些信息，比如哈希值，

67
00:03:38,070 --> 00:03:40,110
strings understand this message hash value,
这些消息哈希后的字符串

68
00:03:40,110 --> 00:03:43,380
how would we do that? Well of course we would say,
我们该如何做呢？

69
00:03:43,380 --> 00:03:47,180
if let label equal display to unwrap the display. And
我们会这样，如果让 label 等于 display 这样去拆包 display

70
00:03:47,180 --> 00:03:50,020
they we would say if let text equal the labels text,
然后我们会让 text 等于 label 的 text

71
00:03:50,020 --> 00:03:54,020
and unwrap that. Then we would say let x equal the text hash
拆包之后，我们在让 x 等于 text 哈希后的值

72
00:03:54,020 --> 00:03:56,820
value, okay? So that is how we would unwrap it.
所以，这就是我们如何去拆包这些信息

73
00:03:56,830 --> 00:03:59,730
Well there is a lot easy way to do it which is this,
当然还有很多更容的方法来做

74
00:03:59,730 --> 00:04:02,700
you just say display?.text?.hashvalue,
你可以这样 display?.text?.hashvalue

75
00:04:02,700 --> 00:04:08,540
okay? So if you use question marks when you're, not when
如果你在这个时候用 ？ 而不是在声明 optional 类型时使用

76
00:04:08,540 --> 00:04:11,640
you're declaring the optional but when you're actually using
这基本上意味着

77
00:04:11,640 --> 00:04:14,840
it, that basically means, try and unwrap this and
尝试去把它们拆包

78
00:04:14,840 --> 00:04:18,380
if you can then use that value to go to the next thing.
拆包后的值是否可以让你去到下一部分

79
00:04:18,380 --> 00:04:21,650
If you can't, just return nil from this whole expression.
如果不行，整个表达是就返回 nil

80
00:04:21,650 --> 00:04:23,150
Okay, this whole display question mark,
这个 dispaly 后面所有的问号，

81
00:04:23,150 --> 00:04:24,590
that typed question mark, that hash value,
那个 哈希 值

82
00:04:24,590 --> 00:04:27,790
that whole expression will return nil if at any point
如果它们当中有任何一点在拆包的时候返回了 nil

83
00:04:27,790 --> 00:04:31,630
any of these things that were changing unwrap turns out to
这整个表达式就会返回 nil

84
00:04:31,630 --> 00:04:35,000
be nil. So, if the display is nil or if the display's text
所以，如果 display 是空的，或者 display 的 text 是空的

85
00:04:35,000 --> 00:04:37,470
is nil then this whole thing is gonna be nil.
那这整个就会变成 nil

86
00:04:37,470 --> 00:04:41,870
So you see let x equal up there? What type do you think
所以你看见让 x 等于它们

87
00:04:41,870 --> 00:04:46,970
x is right there? >> [INAUDIBLE].
这里的 x 是什么类型的 [讨论]

88
00:04:46,980 --> 00:04:48,780
>> Int, almost.
[大概是 Int]

89
00:04:48,780 --> 00:04:51,780
Optional int, exactly. It has to be optional int, because
对，可选 int 类型

90
00:04:51,780 --> 00:04:54,520
any of those things could fail and it would return nil.
因为任何其它东西都可能失败并返回 nil

91
00:04:54,520 --> 00:04:55,520
So it has to be able to take nil. So
所以它可以是 nil 值

92
00:04:55,520 --> 00:04:59,320
that would be an optional int, cuz hash value returns an int,
因为它可以返回一个 int 的哈希值，所以它是一个可选 int

93
00:04:59,320 --> 00:05:03,120
okay. So you're definitely gonna wanna use this,
你肯定会想用这种链条一样的方式去编程

94
00:05:03,130 --> 00:05:05,990
chaining, it really makes your code read beautifully, okay.
它真的让你的代码看起来漂亮了

95
00:05:06,000 --> 00:05:09,000
And the starts make Optionals make a lot of sense why we use
当我们开始使用可选类型的时候会有很多场景去使用它们

96
00:05:09,000 --> 00:05:11,630
them so much. Okay, but there's more.
好的，但是还有别的用法

97
00:05:11,630 --> 00:05:14,640
Here's another Optional syntaxtiture which is ??
这里是 Optional 的另一种用法叫做 ？？

98
00:05:14,640 --> 00:05:18,970
Okay, and this is basically providing a default value
它基本上是在 case 为 nil 的时候提供一个默认的值

99
00:05:18,980 --> 00:05:22,640
in case something is nil. Okay, so let's add an optional
来添加一个可选字符串 s

100
00:05:22,650 --> 00:05:27,380
string here s, okay. I could say if s is not nil,
我可以说，如果 s 不是空

101
00:05:27,380 --> 00:05:30,120
then I'm gonna set my display to be s, okay.
然后我会把我的 display 设置成 s

102
00:05:30,120 --> 00:05:32,920
So let's say I'm setting the display in my calculator, and
这意味我在我的计算器上设置了显示

103
00:05:32,920 --> 00:05:36,060
I never want it to be nil. At worst, I want it to be just
而且我不想让它是空的，最差也得是个空格字符

104
00:05:36,060 --> 00:05:38,690
a space character. Because you might have noticed,
因为你可能注意到了

105
00:05:38,700 --> 00:05:40,490
some of you when you're doing your homework,
当你在做你的一些作业的时候

106
00:05:40,500 --> 00:05:43,000
that if you put nil into a label,
如果你往 label 里面放了 nil

107
00:05:43,000 --> 00:05:45,670
its size will go to zero. Okay,
它的尺寸会变成0

108
00:05:45,670 --> 00:05:50,070
cuz there's no text in there to have a natural size for. So
因为没有文本它就不会有一个天生的尺寸

109
00:05:50,070 --> 00:05:52,870
sometimes you might want to have a code like this where if
所以有时候你可能想要一些这样的代码

110
00:05:52,880 --> 00:05:54,310
you want to put nothing in the display,
如果你往 display 里面放了空的东西

111
00:05:54,310 --> 00:05:57,080
you put a space character, so at least there's something in
你就放一个空格字符，因为这样至少这里有东西让 label 有高度

112
00:05:57,080 --> 00:06:00,920
there for it to have a height, okay? Otherwise your display
否则你设置成 nil 的话

113
00:06:00,920 --> 00:06:03,980
would keep disappearing if you kept setting it to nil. So
你的 display 可能会消失

114
00:06:03,990 --> 00:06:06,890
we can do this, if s does not equal nil then display equals
那么我们可以这样，如果 s 不等于 nil 就让 display 等于 s

115
00:06:06,890 --> 00:06:09,460
s, that should be s exclamation point right there,
用 != 表示不等于

116
00:06:09,460 --> 00:06:12,260
otherwise display equals a space. Okay, well,
否则就 display 就等于一个空格

117
00:06:12,260 --> 00:06:15,000
a much simpler way to put that is with this,
有一个更简单的方法

118
00:06:15,000 --> 00:06:19,430
defaulting operator, which is to say the display.text
让 display.text = s

119
00:06:19,440 --> 00:06:24,170
= s Okay? And that means if s is not nil then unwrap it and
这表示如果 s 不为空，就把它拆包

120
00:06:24,170 --> 00:06:27,680
use that value, otherwise use space.
然后就使用拆包后的值，否则就使用空格

121
00:06:28,710 --> 00:06:31,850
Got that? Everyone understand? I don't see any nodding heads
懂了吗？每个人都懂了吗？我没有看就有人点头

122
00:06:31,850 --> 00:06:34,680
on that one. Make sense, okay? So this is, again, just
理解它，好吗？ 在说一遍

123
00:06:34,680 --> 00:06:38,920
a simple way to have a default value in case an optional is
这是让 optional 在 nil 的情况下有一个默认值的简单的方法

124
00:06:38,920 --> 00:06:43,490
nil. All right so let's talk about another thing, tuples.
继续介绍另一东西，元祖。

125
00:06:43,490 --> 00:06:47,960
All right tuples are a type, okay? In Swift they're really,
元祖是一种类型，在 Swift 中它们非常酷

126
00:06:47,960 --> 00:06:51,670
really cool. They're basically a way to build a type out of
它们是一种构建类型外的类型的基本方法

127
00:06:51,670 --> 00:06:54,170
other types by grouping them, okay? And
好的

128
00:06:54,170 --> 00:06:56,840
you can use it anywhere you can use a type, a tuple can be
你可以在任何地方用一个类型

129
00:06:56,840 --> 00:07:01,640
used anywhere types are valid, okay? So, here's an example.
一个元祖在任何地方使用都是可以的，好的。这里有一个例子

130
00:07:01,640 --> 00:07:06,010
I'm going to create x, okay? This let x, x is a constant.
我要生成一个 x 好的。这是 let x ，x 是一个常量

131
00:07:06,020 --> 00:07:09,950
It's type is a tuple, with a string, int, and
这是一个元祖类型，含有 string, int, 和 double

132
00:07:09,950 --> 00:07:14,020
double. So, even though tuple has the sound, to, in it,
尽管元祖听起来有 two 的声音

133
00:07:14,020 --> 00:07:17,190
it's just not two things. Any number of things can be in
但并不是他有只有两个东西。一个元祖里面可以有任何数量的东西

134
00:07:17,190 --> 00:07:22,460
a tuple okay? So x there is a tuple with string int and
好的，所以 x 是一个含有 string int double 的元祖

135
00:07:22,470 --> 00:07:24,700
double. And I'm even setting it to a value,
我甚至可以往里面设置值

136
00:07:24,700 --> 00:07:28,240
which is just parenthesis, a string, an int, and a double,
用括号包起来一个 string 一个 int 和一个 double

137
00:07:28,240 --> 00:07:33,070
okay? Now how do I get those values out of the tuple?
好的。现在我该如何从这个元祖里面获得值呢

138
00:07:33,080 --> 00:07:34,480
Well there is two ways to do it.
嗯。有两种方法

139
00:07:34,480 --> 00:07:38,950
One is to say, let and then three, identifiers. These
一种，分配三个身份

140
00:07:38,950 --> 00:07:41,920
are basically three local variable names, equals x,
它们是基于三个本地变量来命名的，等于 x

141
00:07:41,920 --> 00:07:45,320
okay? And that's gonna extract the three values and put them,
好的，然后会取出三个值并保存到它们里面去

142
00:07:45,320 --> 00:07:48,320
assign them to word, number, and value, which are gonna
分别放在 word，number，和 value 里

143
00:07:48,320 --> 00:07:51,330
be local variables in this context, okay? Now, if you
它们会在这个上下文里得到蹦迪变量。好的，现在

144
00:07:51,330 --> 00:07:55,730
tried to say let word, comma, number, closed parentheses,
如果你尝试 let (word, number) = x

145
00:07:55,730 --> 00:08:00,170
equal x, the compiler will complain, because word, comma,
编译器是会出错的

146
00:08:00,170 --> 00:08:04,040
number can't match a string in double tuples. Okay? So
应为 word, number 无法和元祖里的 double 关键字匹配。好的

147
00:08:04,040 --> 00:08:07,610
this particular syntax is just putting names on the things in
这一部分的语法就是把这些东西放到这些命名里面

148
00:08:07,610 --> 00:08:11,510
the Tuple so you can use them, so now you can print them out.
你可以这样使用元祖，所以你现在可以把它们打印出来了

149
00:08:11,510 --> 00:08:12,580
Print word. Print number. Print value.
打印 word。打印 number。打印 value。

150
00:08:12,580 --> 00:08:16,520
Value would be of type string. Number would be of type int
word 会是 string 类型，Number 会是 int 类型

151
00:08:16,520 --> 00:08:18,120
and value would be of type double. Okay,
还有 value 会是 double 类型，好的

152
00:08:18,120 --> 00:08:22,090
another way to do it is when you create the tuple, okay,
另一种这么做的方法是，当你在生成元祖时，好的。

153
00:08:22,090 --> 00:08:24,830
you can name each of the things in the tuple. So
你可以为元祖里的每个东西命名。

154
00:08:24,830 --> 00:08:31,070
here I'm letting x, this time be w: String i: Int v: Double.
这里我对 x 的 string 命名为 w，Int 命名为 i，Double 为 v

155
00:08:31,070 --> 00:08:34,640
I'm giving the names w, i and v to the things inside
我在元祖里面分别起了几个名字叫 w，i 和 v

156
00:08:34,640 --> 00:08:37,240
the tuple. I'm still assigning it, just like I did in
我继续给它赋值，就好像我在之前做的一样

157
00:08:37,240 --> 00:08:40,340
the version above. But now if I want to get at the values,
但是现在，如果我想要得到一个值

158
00:08:40,340 --> 00:08:45,550
I can just say x.w, x.i, and x.v to get at the tuple
我可以直接说 x.w，x.i，还有 x.v 来获得元祖中的值

159
00:08:45,550 --> 00:08:48,250
values. See the difference between those two cases?
看出这两种方法的不同之处了吗?

160
00:08:48,250 --> 00:08:51,090
One, you're kind of naming it when you declare the tuple,
一种，在你声明元祖的时候定义一种命名

161
00:08:51,090 --> 00:08:53,920
the other one is you're taking a tuple that you got and
另一种是你拿到一个元祖

162
00:08:53,920 --> 00:08:56,620
you're just extracting the values. And you can mix them.
然后你就取出值。并且你可以混合使用它们

163
00:08:56,630 --> 00:08:59,690
For example I could say let = x.
比如我可以说 let = x

164
00:08:59,700 --> 00:09:02,100
Even though I defined it x to have w, i and v,
尽管我给 x 定义了 w, i 和 v

165
00:09:02,100 --> 00:09:05,370
I could ignore the w, i and v and instead just do
我可以忽略它们

166
00:09:05,370 --> 00:09:10,800
the syntax from the top okay and call it wrd, num and val.
用 word， number 和 value 执行上面那种语法

167
00:09:10,810 --> 00:09:15,340
Okay? So, tuples are cool because you can return
好的。所以，tuple 是很酷的

168
00:09:15,340 --> 00:09:18,750
multiple values from a function with a tuple. Okay?
因为你可以从一个 function 中返回一个有多个值的 tuple

169
00:09:18,750 --> 00:09:22,750
So, we know that returned values are arrow and a type.
所以，我们知道返回的值指向一个类型

170
00:09:22,750 --> 00:09:25,520
Well, since a tuple can be a type, you can go arrow and
好的，当 tuple 可以是一种类型的时候

171
00:09:25,520 --> 00:09:27,660
a tuple, and return values. Yeah?
你可以去指向这个类型，并返回它们的值，对吗？

172
00:09:27,660 --> 00:09:28,260
>> Can you ignore some of
[学生提问]

173
00:09:28,260 --> 00:09:29,320
the values? >> So, question,
所以，问题是

174
00:09:29,330 --> 00:09:30,560
can you ignore some of the values?
你可以屏蔽这些值中的一部分吗？

175
00:09:30,560 --> 00:09:33,590
Absolutely you can, if you use under bar. Underbar and
显然是可以的，你可以使用 underbar

176
00:09:33,600 --> 00:09:37,230
swift is the universal I'm ignoring this character, okay,
swift 里的 underbar 是普遍的，在这一章我先不讲，好的

177
00:09:37,230 --> 00:09:41,670
so you can put underbar in there. So yeah, so
所以你可以把值放在这里，

178
00:09:41,670 --> 00:09:44,070
here I'm returning this tuple weight and
返回一个有宽度和高度的 tuple

179
00:09:44,070 --> 00:09:47,210
height, obviously straight forward how we do that.
显然我们可以直接坐到

180
00:09:47,210 --> 00:09:50,010
So tuples are perfectly valid return values, okay? So
所以 tuople 用来返回值是非常有效的，好的。

181
00:09:50,010 --> 00:09:52,910
you can return multiple things from functions. All right,
所以你可以从这可方法返回多个值

182
00:09:52,920 --> 00:09:56,850
range. So range is quite important, actually,
好的，range 。 range 在 Swift 里是非常重要的

183
00:09:56,850 --> 00:10:00,960
in Swift. It's essentially just two end points,
它基本上就是两个结束点

184
00:10:00,960 --> 00:10:05,330
okay, of anything that can be representative consecutively,
好的，它可以代表任何连续的东西

185
00:10:05,330 --> 00:10:10,560
okay? So range, the type, is generic, like array,
所以，range ，这种类型是普通的，就好像数组

186
00:10:10,570 --> 00:10:13,230
so you can have a range of ints. You can have
所以你可以有一个 int 的 range。

187
00:10:13,240 --> 00:10:16,900
a range of indexes into something or whatever it
你可以有一个莫些东西内部的索引范围

188
00:10:16,910 --> 00:10:20,240
really conceptually just has two things, a startIndex and
或者其它只要有两个东西的连续的东西。有一个起始索引和一个结束索引

189
00:10:20,240 --> 00:10:25,310
a last index, okay, endIndex. An array's range, okay.
一个数组的 range，好的

190
00:10:25,310 --> 00:10:27,950
If you wanted to get an array, arrange into an array,
如果你想要得到一个数组中部分范围的数组

191
00:10:27,950 --> 00:10:28,880
it would be a range of ints,
可以用一个 int 型的 range

192
00:10:28,880 --> 00:10:30,950
because an array is indexed by ints.
因为数组的索引是根据 int 来的

193
00:10:30,950 --> 00:10:34,220
So you would have a range of ints. In fact you know,
所以你应该有一个 int 的 range。

194
00:10:34,220 --> 00:10:36,720
you, there are methods in array where you can say, give
实际上你知道，在 array 里你可以调用一些方法

195
00:10:36,730 --> 00:10:41,900
me this range of yourself, and you specify it as a Range.
提供它们你要指定的范围

196
00:10:41,900 --> 00:10:47,600
A string's range is not Int. Okay, if you wanna substring,
一个字符串的范围不是 Int。 好的，若果你想要子字符串

197
00:10:47,600 --> 00:10:50,440
you cannot use a range of Int. It's actually a range of
你不能使用 Int 的 range。它实际上是一个 String.Index 的range

198
00:10:50,440 --> 00:10:53,740
String.Index, which is a different type than Int. And
它有着和 Int 不同的类型

199
00:10:53,740 --> 00:10:57,680
you're gonna need to read all about that in the assignment,
而且你都会在你的作业里读到这些的

200
00:10:57,680 --> 00:10:59,310
okay? One of the section's in assignment is
好的，作业里面面有一章讲的是

201
00:10:59,320 --> 00:11:01,720
indexing into arrays in the ring assignment.
环形数组中的索引

202
00:11:01,720 --> 00:11:03,550
And you're gonna wanna understand that, okay?
你们要去理解那个，好吗

203
00:11:03,550 --> 00:11:05,790
It's a little bit complicated. I'm not gonna spend
这有一点点复杂。我不能花太多课上的时间

204
00:11:05,790 --> 00:11:07,420
lecture time but just I'm pointing it out to you,
但是我会为你们指出它来

205
00:11:07,420 --> 00:11:10,820
so you could go look at it. Okay? Now, there's special,
所以你们可以去看看，好吗？现在

206
00:11:10,830 --> 00:11:12,790
just like with optionals we've got question marks and
有点特殊，想好像 optional 的问号和叹号

207
00:11:12,800 --> 00:11:16,360
exclamation points. There's some special syntax for
range 有一些特殊的语法

208
00:11:16,370 --> 00:11:20,070
ranges, okay, which is this ...and ..<.
比如 ... 和 ..<

209
00:11:20,070 --> 00:11:24,910
You see them right here? Okay the... ..<!--? Okay?
你们可以看到吧 ... 和 ..<

210
00:11:24,910 --> 00:11:28,810
This means a range right here, okay, that goes from 2 to 3.
这在这里表示一个 range，那个是从 2 到 3

211
00:11:28,810 --> 00:11:33,980
This is a range that goes from 2 to 3 but does not include 3.
这是从 2 到 3 但不包含三

212
00:11:33,980 --> 00:11:37,420
Okay? So that would be just the number 2, right there.
好的，所以那里讲会有两个数字

213
00:11:37,420 --> 00:11:40,050
Okay? Now, see this 4 right here?
好的，现在，看这第四行

214
00:11:40,060 --> 00:11:45,130
4 loops in swift all are 4 in like this.
Swift 中的循环都可以向第四行这样

215
00:11:45,130 --> 00:11:50,500
So if you wanted to go for I equals 1, 2, 10 I plus plus or
如果你想要从 1 加到 2 加到 10 或者加到任何你想要的数值

216
00:11:50,500 --> 00:11:54,000
whatever you would so that with these, ranges like this,
你就可以这样使用 range

217
00:11:54,000 --> 00:11:58,810
okay, for IN 27 to 104 or whatever. Okay? And
好的，总 27 遍历到 104 或者任何其他范围。好的

218
00:11:58,810 --> 00:12:03,040
you can make ranges that are more powerful than just direct
比起直接使用 range 你可以用更有力的方法起使用 range

219
00:12:03,050 --> 00:12:06,510
ranges. I can't talk about that really on time wise, but
我不能花太多时间讨论这个

220
00:12:06,520 --> 00:12:09,080
again check the documentation and
但是在次检查文档的时候你会看到 range 的超出

221
00:12:09,090 --> 00:12:13,050
you'll see out of the ranges, okay? So that's when you see
所以，到那时你就会看到了

222
00:12:13,060 --> 00:12:17,120
that. Okay, let's talk about data structures in Swift.
好的，来谈一谈 Swift 中的结构体

223
00:12:17,130 --> 00:12:19,160
I'm talking about classes, structures and enums.
我讨论类，结构体，和枚举

224
00:12:19,160 --> 00:12:22,500
Okay, you've already seen them in the example. I'm gonna
好的，你们已经在例子里看到它们了

225
00:12:22,500 --> 00:12:25,030
talk about the similarities and the differences.
谈一谈它们的相同和不同

226
00:12:25,030 --> 00:12:27,500
So what's similar between class, struct and enum,
所以，在 class，struct 和 enum 之间有什么相似之处呢

227
00:12:27,500 --> 00:12:30,270
they're declared the same way, right? Just a keyword,
它们都用相同的方式声明对吧。

228
00:12:30,270 --> 00:12:33,270
the name of the thing and then curly braces.
就同这个东西的名字作为关键字，然后收起它们

229
00:12:33,280 --> 00:12:35,980
They all serve like that way. They're also similar and
它们都提供类似的方法。

230
00:12:35,980 --> 00:12:37,310
that they can also have properties and
它们也都可以有属性和方法

231
00:12:37,310 --> 00:12:40,250
functions. Okay? So you can have functions on there,
所以你可以在这里有方法和属性

232
00:12:40,250 --> 00:12:43,280
and you can have properties. Enums cannot have stored
Enum 不能保存属性

233
00:12:43,290 --> 00:12:46,150
properties. Only structs and classes can have stored
只有结构体和类可以存储属性

234
00:12:46,160 --> 00:12:50,160
properties but enums can have computer properties. Okay?
但是枚举可以计算属性

235
00:12:50,160 --> 00:12:52,830
The storage of an enum remember is the cases.
enum 存储的是 case

236
00:12:52,830 --> 00:12:55,730
It's a discrete value thing so it's the cases and
所以它的 case 和它们的相关值

237
00:12:55,730 --> 00:12:58,530
their associated values that's the storage.
是分开存储的

238
00:12:58,870 --> 00:13:02,140
All right they all can have initializers.
当然它们都可以初始化

239
00:13:02,140 --> 00:13:03,940
Okay, we haven't talked much about initializers yet.
好的，我们还没讨论很多关于初始化的东西

240
00:13:03,940 --> 00:13:07,540
We're gonna get that today. Eh, so they're all allowed
我们今天会来说一说。额

241
00:13:07,540 --> 00:13:09,910
to have initializers except enum. Okay,
所以它们除了 enum 都可以初始化

242
00:13:09,910 --> 00:13:12,280
obviously enum doesn't need an initializer because you just
显然 enum 不需要初始化

243
00:13:12,280 --> 00:13:16,320
set it to the discrete value with its associated values.
应为你是是设置了一些离散的值和它们相关的值

244
00:13:16,320 --> 00:13:20,450
Okay? All right. Differences. One, inheritance. Okay?
好的。当然，不同之处，继承。对吗

245
00:13:20,460 --> 00:13:24,860
With classes, you can inherit, structs and enum you can't.
在类中，你可以继承，结构体和枚举不行

246
00:13:24,860 --> 00:13:27,930
Value types, I talked about this before, okay? Structs and
我在这之前介绍过值的类型

247
00:13:27,930 --> 00:13:30,860
enum are value types. They're passed around by value.
结构体和枚举是值的类型。它们通过值来传递

248
00:13:30,870 --> 00:13:33,970
Class is a reference type. You pass pointers to it around. It
类是一种引用类型。通过指针来传递

249
00:13:33,970 --> 00:13:37,910
lives in the heap. Okay? Let's talk a little more about value
它们保存在堆中。好的，来讨论更多关于值和引用

250
00:13:37,910 --> 00:13:42,780
versus reference. Value means that it's copied when passed
值意味着当它作为参数传递个方法是它是个拷贝

251
00:13:42,780 --> 00:13:45,980
as argument to a function, that's kind of obvious. But
这是显而易见的

252
00:13:45,980 --> 00:13:50,480
it also copies when you assign it to another variable.
当你把他分配个另一个变量时它也会拷贝

253
00:13:50,490 --> 00:13:54,250
If I say varx=y if y is a value type,
如果我说 var x = y 如果 y 是一个值类型

254
00:13:54,260 --> 00:13:55,560
x will be a copy of y.
x 会是一个 y 的拷贝

255
00:13:55,560 --> 00:14:00,260
A copy, so if y is an array y might be an array. Okay? And
所以如果 y 是一个 array

256
00:14:00,260 --> 00:14:04,430
you say, x equals y. And then you say, x append this thing,
然后你说 x = y 接着用 x 拼接一些东西

257
00:14:04,430 --> 00:14:07,370
that thing will not be appended to y. Because x
这些东西不会被拼接到 y 上去

258
00:14:07,370 --> 00:14:11,070
was a copy of y. You see what I'm talking about there? Okay.
应为 x 是 y 的一个拷贝。你们明白我在说什么吗？好的

259
00:14:11,070 --> 00:14:12,910
So that's a big difference with value semantics.
所以这是它们之间的一个特别大的不同

260
00:14:12,910 --> 00:14:17,880
Even just assigning them, is a copy of them. A value symantec
甚至个它们赋值也是对它们的拷贝

261
00:14:17,880 --> 00:14:22,780
thing is immutable if it's signed to a let variable.
一个用 let 分配的值是不可变的

262
00:14:22,790 --> 00:14:24,480
Okay? So if you have an array okay,
如果你有一个数组

263
00:14:24,490 --> 00:14:26,990
since that value symmentic cuz an array is a struct.
因为 array 是一个 strut

264
00:14:26,990 --> 00:14:30,220
If you assigned to a let, let x equal an array you cannot
如果你给一个 let 赋值， let x 等于一个数组

265
00:14:30,230 --> 00:14:33,930
append things on to that array cuz it is immutable. Okay,
那你就不能往这个数组上面拼接东西，因为 x 是不可变的

266
00:14:33,930 --> 00:14:38,170
same thing with the dictionary or whatever. Okay. Remember
dictrionary 或者其它东西在这一点上也是相同的

267
00:14:38,170 --> 00:14:40,300
the function parameters. All of them are constants so
记住那些方法的参数，它们都是常量

268
00:14:40,300 --> 00:14:44,670
of course you'd copy them into there, you can't modify them.
所以你得把它们拷贝进来，你不能修改它们

269
00:14:45,110 --> 00:14:48,580
Because of the way copy symmentics work, Swift makes
由于 copy 的工作方式

270
00:14:48,580 --> 00:14:52,650
you when you do have a struct or enum you have to mark all
Swift 会让你在那些 struct 或者 enum 里面

271
00:14:52,650 --> 00:14:55,920
functions that might change that thing. Mutating functions
把可能会改变的方法标记出来

272
00:14:55,920 --> 00:15:00,590
with the keyword mutating. So like mutating func whatever.
用 mutating 关键子来表示可变方法。

273
00:15:00,590 --> 00:15:02,820
Okay? If that function could change that struct.
如果那个方法可以改变他的结构体

274
00:15:02,830 --> 00:15:05,790
And the reason for that is when Swift copies it
当 Swift 拷贝它的时候

275
00:15:05,790 --> 00:15:08,430
it doesn't want to actually make a copy. Okay?
它实际上是不会制作一个备份的

276
00:15:08,430 --> 00:15:11,430
It gets another pointer to it but as soon as you try to
在你视图去改变它的时候

277
00:15:11,430 --> 00:15:15,370
mutate it then it's gonna have to copy it. You see? So
会用一个指正指向它并拷贝这个指针

278
00:15:15,370 --> 00:15:17,640
it's kind of a performance enhancement. So
所以这是一种增强的执行方式

279
00:15:17,640 --> 00:15:20,310
any time you have a struct that has a function that
一旦你的结构体里的方法改变了它的值

280
00:15:20,310 --> 00:15:22,910
changes the values, any of the values of the struct,
这结构体里的任何一个值

281
00:15:22,910 --> 00:15:25,580
you have to put mutating in front so Swift knows
你必须在 Swift 知道你这么做之前将它变为可变的

282
00:15:25,580 --> 00:15:30,220
that you're doing that. Okay, reference types, okay.
好的，参考类型

283
00:15:30,220 --> 00:15:30,850
This is what you're used to,
可能这就是你所用到的

284
00:15:30,850 --> 00:15:32,390
probably. Things are stored in the heap.
东西存放在了堆里

285
00:15:32,390 --> 00:15:35,790
You have a reference to them. Those references are counted
你有一个他们的引用，那些引用会被自动计数

286
00:15:35,790 --> 00:15:39,730
automatically. That means there's no garbage collection
这意味着在 Swift 中是没有垃圾回收机制的

287
00:15:39,730 --> 00:15:42,430
in Swift. All right, there's no mark and sweep in
当然，它们没有标记的时候回从堆里面被清除

288
00:15:42,430 --> 00:15:45,370
the heap. Every single time you create a new pointer to
每当你创建一个新的指针指向堆里的某个东西时

289
00:15:45,370 --> 00:15:47,200
something in the heap Swift keeps track of that and
Swift 会把这个痕迹保存下来增加一个计数值

290
00:15:47,200 --> 00:15:49,970
it keeps incrementing a count. And when that count goes down
然后当计数值成为零的时候

291
00:15:49,970 --> 00:15:53,070
to zero because maybe the last pointer that's pointing to it
可能是最后一个指针不在指向它了

292
00:15:53,080 --> 00:15:56,140
goes out of scope or maybe you assign that last pointer to
或者这最后的指针指向了其它什么东西

293
00:15:56,150 --> 00:15:58,910
point to something else. Nothing points to it.
这块内存不在被指向的时候

294
00:15:58,910 --> 00:16:00,510
It immediately removes that from the heap.
它会立马从堆里面被删除

295
00:16:00,520 --> 00:16:03,850
Okay, predictably removed from the heap immediately.
好的，可以预见会很快的从堆里面移除

296
00:16:03,850 --> 00:16:06,320
So, it's very different than garbage collection, where
所以，这和垃圾回收机制非常不同

297
00:16:06,320 --> 00:16:08,960
garbage collection is kind of going on in the background,
垃圾回收是一种在后台运行

298
00:16:08,960 --> 00:16:10,960
and it might collect a whole bunch from the heap,
一次性手机一整串堆里的东西

299
00:16:10,960 --> 00:16:13,390
all at once. That's been sitting around for a while.
那会等上一段时间

300
00:16:13,400 --> 00:16:13,830
This is predictable,
这是可以预测的

301
00:16:13,830 --> 00:16:16,460
memory management and it's all managed for you. Okay,
这是你可以管理的内存管理

302
00:16:16,470 --> 00:16:19,200
there's only one way that you participate in that, which is
你要参与其中只有一种方法

303
00:16:19,200 --> 00:16:22,740
the weak and strong, which I'll be talking about later,
使用 weak 和 strong。我过会向你们解释

304
00:16:24,370 --> 00:16:26,970
okay? Let's see, constant pointers.
好的，来看指针常量

305
00:16:26,980 --> 00:16:28,680
Okay, if you have a constant pointer to a class,
如果你在一个类里有一个指针常量

306
00:16:28,680 --> 00:16:31,680
obviously it's a pointer, so you're still mutating it,
显然这是一个指针，所以你依然能修改它

307
00:16:31,680 --> 00:16:35,520
right? It's not like a struct where if I say var y = x and
对吗？ 这不像我说的 var y = x 的那种结构

308
00:16:35,520 --> 00:16:38,190
then I add something to y, it doesn't modify x.
当我想要给 y 加点什么的时候，这并不会修改 x

309
00:16:38,190 --> 00:16:41,560
If I say var y = x and they're classes, then if I send
若果我说 var y = x 而且它们都是类

310
00:16:41,560 --> 00:16:44,220
a message to y, it's sending a message to x because they're
然后如果我想 y 发送消息，这会个 x 发送一个消息，因为它们是同一个东西

311
00:16:44,230 --> 00:16:46,630
the same thing. Right they, that same thing lives in
同一个在堆里保存的东西

312
00:16:46,630 --> 00:16:50,700
the heat. There's no copying, so let, all let means is that
没有拷贝，所以 let

313
00:16:50,700 --> 00:16:53,430
pointer's not going to change. It doesn't
所有的 let 意味着那个指针是无法被修改的

314
00:16:53,440 --> 00:16:56,370
mean what the pointer points to won't change.
这不意味着指针指向的东西无法被修改

315
00:16:56,810 --> 00:17:01,380
Okay obviously so when you pass a pointer to a class
显然，当你把指针当做一个参数传递给类的时候

316
00:17:01,380 --> 00:17:04,440
as an argument, then it does not make a copy, it's just
它不会产生一个拷贝

317
00:17:04,450 --> 00:17:08,580
passing a pointer. Okay. Now how do you know which to use?
它就传递了一个指针。好的，现在你知道该怎么用了吗？

318
00:17:08,580 --> 00:17:10,120
Struct versus class, specially.
特别的，结构和类

319
00:17:10,120 --> 00:17:13,890
Okay, enum is pretty obvious. But struct versus class well.
enum 是很明显的。除了结构和类

320
00:17:13,890 --> 00:17:15,890
Usually you're gonna choose class over struct.
通常你会在类和结构中选一个

321
00:17:15,890 --> 00:17:17,790
Okay. Because this is object oriented program.
因为这是面向对象编程

322
00:17:17,790 --> 00:17:19,630
You use to do it and that's going to be fine.
你这样使用会更好一点

323
00:17:19,630 --> 00:17:22,360
Struct is gonna be used for more fundamental types.
Struct 更多被用作基础类型

324
00:17:22,360 --> 00:17:25,370
Okay, things like strings and doubles, and ints and arrays
向是 string 和 double ， int 和 array 在 diction 里

325
00:17:25,370 --> 00:17:28,500
in dictionaries, and also for drawing, points, rectangles.
也会为了绘图有点，矩形

326
00:17:28,500 --> 00:17:30,740
Do you see what I'm saying, smaller things that
你知道我在时候什么，一个更小的独立的东西

327
00:17:30,740 --> 00:17:33,840
are self-contained, that it makes sense to copy by value.
用在需要复制值的场景上

328
00:17:33,840 --> 00:17:36,340
You want the value semantic, that's gonna be your primary
你要这值的语言。当你在传递这值的时候

329
00:17:36,350 --> 00:17:38,110
reason for choosing struct as you want values
你想要这些值的语义

330
00:17:38,110 --> 00:17:41,950
semantics when you're passing this thing around. Otherwise,
会成为你选在 struct 的主要原因

331
00:17:41,950 --> 00:17:45,090
you're gonna choose classes, okay? Anything big is almost
否则你就选类

332
00:17:45,090 --> 00:17:50,660
certainly gonna use the class, all right? Okay.
任何大型的东西坑定会使用类，对吗？

333
00:17:50,660 --> 00:17:53,730
On the methods. So now we are gonna talk about the syntax
好的。这这些方法里，我们要来说说这些方法的语法

334
00:17:53,730 --> 00:17:57,360
of methods. Okay, I showed you this in class a little bit but
在这个类里我会展示一点

335
00:17:57,370 --> 00:18:00,370
I'm gonna talk about the full semantics here of it.
我还会介绍它在这里的完整的语义

336
00:18:00,370 --> 00:18:04,140
So interesting about the naming of functions, so
这些方法的命名挺有趣的

337
00:18:04,140 --> 00:18:06,870
here is someone defining a method and here is someone
这里定义了一个方法

338
00:18:06,880 --> 00:18:10,440
calling this method. Okay? Okay, so watch this colored
这里调用了这个方法。好的？好，在我讨论这几种东西的时候

339
00:18:10,450 --> 00:18:15,280
stuff going on as I talk about these various things going on.
注意这些高亮的部分

340
00:18:15,280 --> 00:18:19,650
So all parameters to functions have an internal name and
所有方法的参数都有一个内部的名字和一个外部的名字

341
00:18:19,660 --> 00:18:21,620
an external name, every single parameter.
是每一个参数都有

342
00:18:21,620 --> 00:18:24,590
So here's the first parameter, here's the second parameter,
那么这里是第一个参数，这里是第二个参数

343
00:18:24,590 --> 00:18:28,300
they both have an external name and an internal name.
它们都有一个外部的名字和一个内部的名字

344
00:18:28,300 --> 00:18:31,200
Okay? The external name comes first. Internal name comes
好的。先说外部名字，在说内部名字

345
00:18:31,200 --> 00:18:35,640
second. The internal name is the name of the local
内部名字是在你的方法里面的本地变量的命名

346
00:18:35,640 --> 00:18:39,770
variable that's gonna be used inside your method.

347
00:18:39,780 --> 00:18:41,540
All right? So that's this one right here,
所以这就是内部命名

348
00:18:41,540 --> 00:18:44,880
internal name. Shows up right before the colon. Okay?
就是出现在这冒号之前的东西

349
00:18:44,880 --> 00:18:46,750
First and second. You can see how first and
第一个和第二个

350
00:18:46,750 --> 00:18:50,720
second are the names I used for those inside my function.
你可以看到在我的方法里我是如何给第一个和第二个起名的

351
00:18:50,720 --> 00:18:53,090
Don't appear anywhere here. Notice first and
不要出现在别的地方。

352
00:18:53,090 --> 00:18:56,660
second do not appear in the funk bar call. Okay,
注意第一个和第二够不在方法块后面出现

353
00:18:56,660 --> 00:19:00,190
cuz those are the internal names. The external name
因为它们是内部的名字

354
00:19:00,200 --> 00:19:04,760
is what the caller uses when they call this method. Okay,
当这个方法被调用的时候这个方法会被使用

355
00:19:04,770 --> 00:19:09,200
so you can see bar down there. It says externalFirst: 123,
你可以看到这里有个下划线。这表示 外部第一个参数：123，

356
00:19:09,200 --> 00:19:14,170
externalSecond: 5.5, right? Okay, it's using the external
外部第二参数：5.5，好的

357
00:19:14,180 --> 00:19:16,110
names first and second never appear but
第一个和第二个名字并没有出现

358
00:19:16,110 --> 00:19:19,480
first and second are still used in the implementation,
但它们仍然能够被实现别使用

359
00:19:19,480 --> 00:19:22,850
those in the internal names. Okay,
可以在方法里用它们的内部名字

360
00:19:22,850 --> 00:19:26,020
you can put an under bar if you don't want callers
如果你不想让你的传递参数使用外部的名字

361
00:19:26,020 --> 00:19:30,560
to use an external name at all for a given parameter. Okay,
你可以使用 _ 来替代它们

362
00:19:30,560 --> 00:19:34,690
so if you put underbar as the external name then there will
所以你要是在外部名字的地方放了一个 _ 那这里有不会有外部参数

363
00:19:34,700 --> 00:19:39,330
be no external parameters. So you see it says foo(123), not
比如你调用 foo(123)

364
00:19:39,330 --> 00:19:44,170
foo(externalFirst or anything, it's just nothing, 123. And
不用调用 foo(外部第一个参数名或者其它什么东西，什么都不用，就写123

365
00:19:44,170 --> 00:19:49,140
in fact, this is the default for the first parameter.
实际上，第一个参数默认就是这么做的

366
00:19:49,140 --> 00:19:51,850
The first parameter defaults to under bar, you don't need
第一个参数默认就是 _

367
00:19:51,850 --> 00:19:54,510
to put an under bar there when you're creating a function.
当你创建一个方法的时候你不需要再在那里放 _

368
00:19:54,520 --> 00:19:57,850
Just by default an under bar would be put there for you,
那里默认就为你放了一个 _

369
00:19:57,850 --> 00:20:01,790
okay? Now you could specify an external name for the first,
现在你指定第一个外部参数的名字，这是合法的

370
00:20:01,790 --> 00:20:04,820
it's legal. Okay, I'll show you that in a second. But
我会展示第二个怎么做

371
00:20:04,830 --> 00:20:07,730
by default under bar is the external name for the first
默认的 _ 只有第一个外部命名才有

372
00:20:07,730 --> 00:20:11,900
parameter only. All the other ones. Okay? The default is
那么所有其它的是什么呢？

373
00:20:11,900 --> 00:20:15,500
the internal name. So, if you don't have an external name,
它们默认都是内部名字。所以如果你不想要一个外部名字

374
00:20:15,500 --> 00:20:21,680
then it defaults to being the internal name. Got it?
它们默认会是一个内部的名字。明白了吗？

375
00:20:21,680 --> 00:20:25,380
Okay. Any parameter's external name can be changed, okay?
好的。任何参数的外部名字都是可以修改的

376
00:20:25,380 --> 00:20:28,580
You can change even the second one to be underbar, so
你甚至可以把第二个改成 _

377
00:20:28,580 --> 00:20:32,320
that the second one has no name, okay?
这样第二个就没有名字了，对吗？

378
00:20:32,320 --> 00:20:35,690
But don't do this, okay? It's very anti Swift
当时不要这样做，好吗？

379
00:20:35,690 --> 00:20:39,890
to either remove the second parameter name or
把第二个参数移除或者添加到第一个参数，是很反 Swift 的

380
00:20:39,900 --> 00:20:43,500
to add it back to the first. Adding to the first is
添加到第一个可能不是很反 Swift

381
00:20:43,500 --> 00:20:46,400
probably less anti Swift, there is probably some case
可能在某些场景里会需要这么做

382
00:20:46,400 --> 00:20:49,200
where that might actually make some sense. Removing them for
但是后面要把它们删掉也是非常麻烦的

383
00:20:49,200 --> 00:20:51,740
subsequent ones is probably really bad. Okay,

384
00:20:51,740 --> 00:20:55,310
I don't think I've ever had to do that in my entire life of
在我用 Swift 写程序的时候，我不记得我曾经这么做过

385
00:20:55,310 --> 00:20:55,680
writing swift so.

386
00:20:55,680 --> 00:21:00,350
All right now, methods are obviously overriddeable,
现在，方法是可以被覆盖的

387
00:21:00,350 --> 00:21:04,280
this is object orientated programming. Right and the way
因为这是面向对象编程

388
00:21:04,290 --> 00:21:07,190
you do it, you just put the word override in front of
你只需要在 func 或者 var 前面加 override 关键字

389
00:21:07,190 --> 00:21:10,120
the func or var. Both properties and functions can
属性和方法都是可以被覆盖的

390
00:21:10,130 --> 00:21:12,960
be overridden right, so you put override in there. It is
所以你把 override 放在这里

391
00:21:12,960 --> 00:21:18,200
possible to mark a method or a property final in which case
它可以在子类的情况里用来标记方法和属性

392
00:21:18,200 --> 00:21:21,270
no one can subclasses. Okay, there won't be a list,
一个子类不能再类前放 override

393
00:21:21,270 --> 00:21:24,740
a subclass can't say override that thing. The compiler won't
编译器不允许这么做

394
00:21:24,740 --> 00:21:29,110
let them. Okay, you can also mark an entire class final,
你也可以在类的最后标记一个入口

395
00:21:29,110 --> 00:21:33,980
and then the whole thing is not subclassable. All right?
然后整个类就不能有子类了

396
00:21:33,980 --> 00:21:39,090
Now, both types and instances can have methods and
现在类和对象都可以有方法和属性

397
00:21:39,090 --> 00:21:42,060
properties. What does that mean? So, so
这意味着什么呢

398
00:21:42,060 --> 00:21:43,560
far in all the demos we've done,
现在我们已经完成了所有的演示

399
00:21:43,560 --> 00:21:45,990
all you've seen is instance methods and
你看到的都是对象方法和对象属性

400
00:21:45,990 --> 00:21:47,330
instance properties. In other words,
换言之

401
00:21:47,330 --> 00:21:50,530
they are properties that you get from an instance of
它们是你从一个对象中拿出来的属性

402
00:21:50,530 --> 00:21:53,100
the thing. Okay, an instance of the calculator brain.
好的，一个计算器大脑的对象

403
00:21:53,100 --> 00:21:58,070
Someone actually created a calculator brain in the heap
实际上你已经在堆里创建了一个计算器的大脑并且给它发送消息

404
00:21:58,070 --> 00:22:01,510
and you send it messages, okay. Those are instances
那些事对象消息

405
00:22:01,510 --> 00:22:05,910
messages, Instances methods and instances properties. But
对象方法和对象属性

406
00:22:05,910 --> 00:22:07,180
it is possible to have methods and
然而在它的类里它还能有自己的方法和属性

407
00:22:07,180 --> 00:22:10,420
properties on the type itself, so calculator brain,
所以在计算器大脑这个类里面它可以有方法，对吗

408
00:22:10,420 --> 00:22:14,250
the type can have functions, okay? And here's what
这里是调用他们时的样子

409
00:22:14,260 --> 00:22:17,620
it looks like to call them. So here I have a little example.
我这里有一个小例子

410
00:22:17,630 --> 00:22:20,890
Here I have a var d which is a double, okay?
我这里有有一个 double 的变量 b

411
00:22:20,900 --> 00:22:24,460
And it's set to some value. So this d is an instance of
然和我给它设置一些值，所以这个 d 是一个 double 的实例

412
00:22:24,470 --> 00:22:26,830
a double. It is an actual double that has some value,
这个 double 实际上有一些值

413
00:22:26,840 --> 00:22:30,740
all right? And here I'm checking by sending a message,
我通过发送一个消息来检查这一点

414
00:22:30,740 --> 00:22:34,240
an instance method right here. Or probably a property
它是一个对象的方法，也可能是一个属性

415
00:22:34,240 --> 00:22:38,380
actually. Instance property on D, where I'm asking
对象的 D 属性如果是负数的

416
00:22:38,380 --> 00:22:41,380
if it's signed is the minus sign, I'm just making this up,
我就把他变成正数

417
00:22:41,380 --> 00:22:43,820
there's probably not even such a method on double.
在 double 里面可能没有这样一个方法

418
00:22:43,820 --> 00:22:47,920
But that would be an instance property or method and
我会向 D 的属性或对象发送消息

419
00:22:47,920 --> 00:22:48,760
I would be sending it to D,

420
00:22:48,760 --> 00:22:52,260
which is an instance. If it does have a minus sign,
如果它没有负号

421
00:22:52,260 --> 00:22:55,700
I'm going to use a type property. Or type function,
我会使用一个类属性

422
00:22:55,700 --> 00:23:00,970
rather, of double here, to change its probably absolute
或者在 double 里的这个类方法里会把它变成绝对值

423
00:23:00,970 --> 00:23:03,800
value, so it'd probably change its sign there. Okay.
所以我可能在这里改变它的符号

424
00:23:03,810 --> 00:23:07,140
Notice the syntax here, Double.abs, okay.
好的。注意这里的语法 Double.abs

425
00:23:07,140 --> 00:23:09,640
This is the name of the function abs, okay, and
这个方法的名字叫 abs

426
00:23:09,640 --> 00:23:13,080
I'm accessing it by saying Double. So in other words, I'm
然后我通过向 Double 发消息来访问它

427
00:23:13,080 --> 00:23:17,320
putting the name of the class. Not an instance of a class,
换句话说，我把这个类名放在这里。不是一个类的对象

428
00:23:17,320 --> 00:23:19,850
not a variable of that class, but the actual name of
也不是一个类的变量，而是一个类的名字

429
00:23:19,860 --> 00:23:24,460
the class, dot abs. Okay, that's it's gonna be defined,
.abs 好的。那个 abs 会被定义

430
00:23:24,460 --> 00:23:29,700
that abs, will be defined like this. Static func abs.
会用这种方法定义 Static func abs

431
00:23:29,700 --> 00:23:32,800
This would be in the class double. And you put this word
这会在 double 类的里面

432
00:23:32,800 --> 00:23:37,270
static and that says that you don't send this to double
在这里放关键字 static 意味着你不会把它发送给 double 对象

433
00:23:37,270 --> 00:23:41,040
instances. You send it to the Double class by saying capital
你会用大写的 D ，Double 点，发送给 Double 这个类

434
00:23:41,040 --> 00:23:45,680
D Double dot. Okay? Why do we have these things? Okay these
为什么我们会有这些东西？

435
00:23:45,680 --> 00:23:49,880
are usually utility functions kind of global functions but
我们经常会需要一些全局的功能函数

436
00:23:49,890 --> 00:23:52,820
they're really strongly associated with the class. So
但是他们和这些类有很强的关联的

437
00:23:52,820 --> 00:23:54,350
we put them as class methods, okay?
所以我们把他们放到类方法里面，好吗？

438
00:23:54,360 --> 00:23:58,090
That's what they're for, mostly. Maybe you have a class
这是它们存在的主要原因

439
00:23:58,090 --> 00:24:02,530
method that creates Shared instances of a class, okay.
或许你会有个类方法来创建一个类的共享对象

440
00:24:02,530 --> 00:24:05,630
Something like that, we'll see a few of these.
像这样，我们会看到这些

441
00:24:05,630 --> 00:24:06,530
Once you start to see them in action,
一旦你在实践中看见他们

442
00:24:06,540 --> 00:24:08,270
you'll start to understand. But I just wanna make sure you
你就会明白的。

443
00:24:08,270 --> 00:24:10,800
understand that there is a difference between these two
但是我想确保你们理解这两者之间是不同的

444
00:24:10,810 --> 00:24:13,470
and this static that makes a difference on declaration,
这个 static 在声明的时候是不同的

445
00:24:13,480 --> 00:24:16,380
okay. That's also in the reading assignment, make sure
好的。那些也在阅读作业里面

446
00:24:16,380 --> 00:24:19,180
you read that carefully. In the homework assignment,
确保你仔细的阅读过了

447
00:24:19,180 --> 00:24:23,120
I even say be careful to read this carefully. All right,
在作业里面我甚至也说了仔细阅读

448
00:24:23,120 --> 00:24:25,420
properties, okay. Properties are really cool.
好的。属性是很酷的

449
00:24:25,420 --> 00:24:27,890
In Swift we're only just scratching the surface so
在 Swift 里我们才刚刚揭开它的表面远不及它所能做的

450
00:24:27,890 --> 00:24:31,220
far of what they can do. But one really cool thing about
但是有一件关于它的很酷低是

451
00:24:31,230 --> 00:24:35,830
them is that you can observe changes to a property, okay.
你可以观察一个属性的改变

452
00:24:35,830 --> 00:24:39,430
And you need to do that by, here's your var, okay. This is
而且你需要这样做，这是你的变量。

453
00:24:39,430 --> 00:24:41,570
a stored property, this is not a computed property,
这是存储的属性，这不是一个计算的属性而是用来存储的

454
00:24:41,570 --> 00:24:45,310
it's stored, okay. It stores in ints, its value is 42. But
它存在 int 里，这个值是 42。

455
00:24:45,310 --> 00:24:47,970
I'm putting the curly braces after it, not because I'm
我把大括号放在它的后面，我要去得到和设置它

456
00:24:47,980 --> 00:24:51,010
gonna do get and set, I'm not computing it. But
我不去计算它

457
00:24:51,010 --> 00:24:56,150
I'm gonna add willSet and/or didSet, okay. So willSet and
但是我会使用 willSet 和 didSet。好的

458
00:24:56,150 --> 00:24:59,050
didSet, this is just code in here that's gonna get called
willSet 和 didSet，当调用 get 和 set 时就会调用者两个方法

459
00:24:59,050 --> 00:25:04,260
whenever this thing gets set. Okay, before and after. Before
好的，在这之前或在这之后。

460
00:25:04,260 --> 00:25:08,230
it gets set, after it's been set, okay. And inside there
这 get 之前和 set 之后，好的

461
00:25:08,230 --> 00:25:11,100
newValue is going to be the value it's going to be set to
在设置到 willset 的时候 newValue 就是要设置的值

462
00:25:11,100 --> 00:25:14,500
in willSet. And oldValue is this value it used to have in
当你执行 didSet， oldValue 就是已经存储着的值

463
00:25:14,500 --> 00:25:19,770
did, when you're executing in didSet, okay. So, pretty cool.
好的，非常酷

464
00:25:19,770 --> 00:25:23,280
And you can do that for stored properties, you can do it for
你可以这样来存储属性，你也可以对继承的属性这么做

465
00:25:23,280 --> 00:25:25,880
inherited properties, properties you inherit even,
你甚至可以继承属性

466
00:25:25,880 --> 00:25:29,550
okay. And you can do it for computed properties as well,
你也可以用它来计算属性

467
00:25:29,550 --> 00:25:33,720
okay. Also here, this will be,
好的

468
00:25:33,720 --> 00:25:37,420
one thing to note about this is these willSets and didSets,
这些 willSet 和 didSet 要注意的是

469
00:25:37,430 --> 00:25:41,660
if you mutate a value type they will get called,
如果你改变一个值的类型 get 会被调用

470
00:25:41,660 --> 00:25:45,600
okay. So, operations here from our calculator brain,
所以我们对计算器大脑的操作放在这里

471
00:25:45,600 --> 00:25:49,100
dictionary string operation that is a value type,
字典字符串操作是一个值类型

472
00:25:49,100 --> 00:25:51,740
dictionary is a value type, right. So
字典是一个值类型

473
00:25:51,740 --> 00:25:54,010
if you add something to this dictionary,
所以如果你往字典里加了什么

474
00:25:54,010 --> 00:25:57,580
this will get called. willSet and didSet will get called,
会调用 get。willSet 和 didSet 会被调用

475
00:25:57,580 --> 00:26:00,310
okay. That's not true if it's a reference type, okay.
如果它是一个引用类型的话这么做是无效的

476
00:26:00,320 --> 00:26:03,180
If that if this property isn't a class and
如果这属性不是类而且你修改了类的某个地方

477
00:26:03,180 --> 00:26:06,120
you change the class somehow, it can't detect that, so
它是不会检测到的

478
00:26:06,120 --> 00:26:08,390
it doesn't do willSet and didSet, okay.
所以它不会执行 willSet 和 didSet

479
00:26:08,390 --> 00:26:13,930
You have to change the pointer itself. All right, okay.
你必须改变指针本身

480
00:26:13,930 --> 00:26:17,100
One very common thing to do in these willSets and didSets is
通常 willSet 和 didiSet 的用途是更新 UI

481
00:26:17,100 --> 00:26:20,700
update the UI. You got a method in your controller.
你在你的控制器里得到一个方法

482
00:26:20,700 --> 00:26:22,440
You set some value in controller that changes
你改变了控制器某处的值就会在 UI 上显示出来

483
00:26:22,440 --> 00:26:25,170
the way the UI would look. You ask your view to
你要求你的 View 重绘

484
00:26:25,170 --> 00:26:27,370
draw itself again, okay. Very, very common.
好的。非常非常常见

485
00:26:27,380 --> 00:26:30,180
We're gonna be doing that up the wazoo in the next lecture,
我们会在下一节使用它们

486
00:26:30,180 --> 00:26:35,050
okay. All right. Lazy initialization. So, this is
好的。懒加载

487
00:26:35,050 --> 00:26:38,480
a little bit of a cheat code of Swift right here.
这是 swift 种有点欺骗性的代码

488
00:26:38,490 --> 00:26:43,590
You can declare vars to be lazily instantiated.
你可以声明一个懒加载的变量

489
00:26:43,590 --> 00:26:47,690
Which means that, their value, this equals calculator brain,
这意味它们等于计算器的大脑实际上不会执行

490
00:26:47,700 --> 00:26:51,430
will not actually happen. That assignment will not happen
知道有些地方需要调用它了才会执行分配

491
00:26:51,430 --> 00:26:53,700
until someone asks for the brain, okay.
好的

492
00:26:53,700 --> 00:26:56,640
If someone tries to send a message to this brain or
若果有什么动向想个这个大脑发一个信息

493
00:26:56,640 --> 00:26:57,970
get a property to this brain,
或者从这个大脑里拿到一个信息

494
00:26:57,970 --> 00:26:58,870
then it's gonna get initialized.
然后它就会被初始化

495
00:26:58,870 --> 00:27:01,370
So in other words, it's lazily instantiated, okay.
换句话说，这就是懒加载

496
00:27:01,380 --> 00:27:04,810
And you can do it like that, okay. Just lazy var brain,
而且你可以像这样做。就 lazy var brain

497
00:27:04,810 --> 00:27:08,150
calculatorbrain. You can do down here, okay.
你可以在这里做

498
00:27:08,150 --> 00:27:12,250
Lazy var myProperty = self.initializedMyProperty.
Lazy var myProperty = self.initializedMyProperty.

499
00:27:12,250 --> 00:27:16,220
So, I'm calling a method on myself to initialize one of my
所以我告诉我自己去初始化我的一个属性

500
00:27:16,220 --> 00:27:20,030
properties. Normally, this would be illegal

501
00:27:20,030 --> 00:27:22,730
without the lazy. The reason this would be illegal

502
00:27:22,730 --> 00:27:25,500
without the lazy is that you cannot send any messages to

503
00:27:25,500 --> 00:27:28,800
yourself or access any of your properties until you're fully

504
00:27:28,800 --> 00:27:32,840
initialized, okay. And this is part of your initialization,

505
00:27:32,840 --> 00:27:34,710
so it's a catch 22, you can't do it. But

506
00:27:34,710 --> 00:27:38,780
if you make this lazy, now you can. Because it's not actually

507
00:27:38,780 --> 00:27:41,150
going to happen until after you're fully initialized and

508
00:27:41,150 --> 00:27:44,680
someone comes along and tries to access myProperty, okay. No

509
00:27:44,690 --> 00:27:47,750
one can access myProperty for your initialize anyway. So,

510
00:27:47,760 --> 00:27:50,590
once you're fully initialized, I'm gonna access myProperty,

511
00:27:50,590 --> 00:27:54,830
lazy, boom. This method will get called to initialize you,

512
00:27:54,830 --> 00:27:57,460
got it? And how about this one in the middle here,

513
00:27:57,470 --> 00:28:02,570
some property of this given type equals a closure

514
00:28:03,040 --> 00:28:04,340
with open parentheses,

515
00:28:04,340 --> 00:28:07,640
closed parentheses on the end. This just means,

516
00:28:07,640 --> 00:28:13,080
initialize this by executing the code inside this closure,

517
00:28:13,080 --> 00:28:15,420
okay. It's very similar to doing

518
00:28:15,420 --> 00:28:18,080
self.initializeMyProperty but you're putting the code

519
00:28:18,090 --> 00:28:20,320
in this closure instead of putting it in initialize

520
00:28:20,320 --> 00:28:24,060
myProperty, whatever that method is, okay. Now,

521
00:28:24,060 --> 00:28:28,330
normally inside here, okay. If this weren't lazy,

522
00:28:28,330 --> 00:28:31,600
you would not be able to access self in here.

523
00:28:31,600 --> 00:28:35,070
Because again, this is a part of initialization, you can't

524
00:28:35,070 --> 00:28:37,970
do anything with self until you're fully initialized. So

525
00:28:37,970 --> 00:28:38,940
if you tried to put self in here,

526
00:28:38,940 --> 00:28:42,210
the compiler will complain. But if you make it lazy,

527
00:28:42,210 --> 00:28:46,250
now you can access self in here. Got it?

528
00:28:46,250 --> 00:28:49,080
Call your own methods or whatever you wanna do, okay.

529
00:28:49,080 --> 00:28:52,690
So that's lazy. The reason this is kind of a cheat code

530
00:28:52,690 --> 00:28:57,120
is that this lazy business satisfies the requirement

531
00:28:57,130 --> 00:29:00,690
that all your vars have to be initialized, okay. So even

532
00:29:00,700 --> 00:29:03,860
these, though these things are being initialized lazily,

533
00:29:03,870 --> 00:29:05,570
they're still being initialized for

534
00:29:05,570 --> 00:29:08,130
the purposes of that rule that all your vars have to be

535
00:29:08,140 --> 00:29:11,200
initialized. This kind of will often keep you from having to

536
00:29:11,210 --> 00:29:13,210
write an initializer. You won't need an init,

537
00:29:13,210 --> 00:29:16,010
because of this lazily do it, okay.

538
00:29:16,010 --> 00:29:19,180
That's why I say it's kind of a cheat code a little bit,

539
00:29:19,180 --> 00:29:22,220
okay. One thing about lazy, they always have to be var.

540
00:29:22,220 --> 00:29:26,120
So there's no such thing as lazy let, okay. Lazy var

541
00:29:26,120 --> 00:29:30,760
only, okay. You can also use laziness to get around some

542
00:29:30,760 --> 00:29:34,090
dependency issues, if you have one var depends on another. If

543
00:29:34,100 --> 00:29:36,960
you can make one of them lazy, then that'll be fine, right.

544
00:29:36,970 --> 00:29:40,400
Cuz the lazy one will call the one that gets pre-initialized,

545
00:29:40,400 --> 00:29:45,270
okay. All right, let's talk about array.

546
00:29:45,270 --> 00:29:48,240
Okay, I'm not gonna spend much time on this cuz array you're

547
00:29:48,240 --> 00:29:49,640
used to array, you know what array is.

548
00:29:49,640 --> 00:29:52,040
In other languages, it's pretty much the same in Swift.

549
00:29:52,050 --> 00:29:54,910
So I'm just gonna try and cover the syntax a little bit.

550
00:29:54,920 --> 00:29:57,550
One thing is we've been using this kind of syntax for

551
00:29:57,550 --> 00:30:01,790
dictionary, right, dictionary angle, extreme colon

552
00:30:01,790 --> 00:30:06,090
operation, remember that? This is the formal

553
00:30:07,200 --> 00:30:10,400
syntax for an array but this square bracket,

554
00:30:10,400 --> 00:30:13,130
string closed square bracket is more informal and

555
00:30:13,130 --> 00:30:17,900
it's the one we use, okay. So as we go forward, we're gonna

556
00:30:17,910 --> 00:30:23,010
use [string] to mean the type array of string, okay.

557
00:30:23,010 --> 00:30:28,710
And similarly for dictionary, [key:value]. That is

558
00:30:28,720 --> 00:30:34,690
dictionary with keys of this and values of that type, okay.

559
00:30:34,690 --> 00:30:35,960
Now, this is the type,

560
00:30:35,960 --> 00:30:38,690
so the open parenthesis close parenthesis on the end just

561
00:30:38,690 --> 00:30:41,590
means that I'm calling the initializer with no arguments.

562
00:30:41,600 --> 00:30:44,600
Same as up here. So don't get confused by that, okay.

563
00:30:44,600 --> 00:30:46,530
So that just means I'm initializing,

564
00:30:46,530 --> 00:30:50,140
I'm creating an instance of an array of string, okay. That's

565
00:30:50,140 --> 00:30:54,270
what both of those mean. So, I can also create arrays and

566
00:30:54,280 --> 00:30:58,240
initialize them by just saying some variable like animals

567
00:30:58,250 --> 00:31:02,110
there which is constant let animals = [ list a bunch of

568
00:31:02,120 --> 00:31:05,320
things ]. That creates an array of those things.

569
00:31:05,320 --> 00:31:08,420
And notice I don't specify any type here.

570
00:31:08,420 --> 00:31:10,790
Why, why do I get away with that? What does Swift do?

571
00:31:10,790 --> 00:31:15,900
It infers type. So, we would look at this and say string,

572
00:31:15,900 --> 00:31:16,960
string, string, string all right.

573
00:31:16,970 --> 00:31:20,430
This is an array of string. Now if I went giraffe, cow,

574
00:31:20,440 --> 00:31:24,970
three, bird, then Swift would complain, can't infer the type

575
00:31:24,970 --> 00:31:28,010
of that array, because it's not all the same type.

576
00:31:28,010 --> 00:31:30,910
Okay, so we'd infer it here. Now, notice this

577
00:31:30,910 --> 00:31:34,380
animals.append("Ostrich"), if I put an Ostrich in here,

578
00:31:34,380 --> 00:31:37,520
this will not compile, okay. Compiler will say no,

579
00:31:37,520 --> 00:31:41,420
that's because animals is let, it's a constant.

580
00:31:41,420 --> 00:31:45,020
So this is a constant array, it can not be modified.

581
00:31:45,030 --> 00:31:50,460
If I put var right here, no problem, it would work, okay.

582
00:31:50,470 --> 00:31:53,670
Now, if I say let animal = animals[5].

583
00:31:53,670 --> 00:31:57,440
That's gonna crash my program. Array index out of bounds,

584
00:31:57,440 --> 00:31:59,910
just like most Programming systems do. It's one

585
00:31:59,910 --> 00:32:03,210
of the few cases that you can crash your program in Swift.

586
00:32:03,210 --> 00:32:06,880
We know unwrapping optionals is one, this is another one.

587
00:32:06,880 --> 00:32:08,010
If you array index out of bounds,

588
00:32:08,020 --> 00:32:13,250
it will crash, okay? How do you enumerate array?

589
00:32:13,250 --> 00:32:16,020
I wanna look at everything in an array. Yeah, I could do for

590
00:32:16,020 --> 00:32:19,990
with a range 0.., the length of the array, right?

591
00:32:19,990 --> 00:32:22,400
0.., less than sign, length of the array. But

592
00:32:22,400 --> 00:32:24,260
that's not how you would do it, you would just say, for

593
00:32:24,270 --> 00:32:28,900
animal in animals, okay? This is gonna loop through, and

594
00:32:28,900 --> 00:32:30,970
this local variable is gonna be assigned each

595
00:32:30,970 --> 00:32:35,840
of the animals, okay? That's how you enumerate an array.

596
00:32:36,210 --> 00:32:38,280
All right, interesting Array<T> methods.

597
00:32:38,280 --> 00:32:40,550
Okay, I'm not gonna spend a lot of time on this slide.

598
00:32:40,550 --> 00:32:43,050
But I really want you to understand that these methods

599
00:32:43,050 --> 00:32:45,580
are here, okay, and you're gonna wanna use them.

600
00:32:45,590 --> 00:32:46,490
They will really clean up your code.

601
00:32:46,490 --> 00:32:49,590
They'll keep you from doing a lot of code, this like for

602
00:32:49,590 --> 00:32:52,960
enumerate through my array, do this, if then, this then,

603
00:32:52,960 --> 00:32:56,200
collect it in another array, all that kinda stuff you can

604
00:32:56,200 --> 00:32:59,000
put in one liners, okay? So what do these things do?

605
00:32:59,000 --> 00:33:04,070
These things use closures to operate on arrays. So filter,

606
00:33:04,070 --> 00:33:06,710
okay, is a method in Array. You send it to it.

607
00:33:06,710 --> 00:33:11,710
You provide a closure, which takes whatever type is in the,

608
00:33:11,710 --> 00:33:14,510
in the array and returns a bool. And it just

609
00:33:14,520 --> 00:33:18,920
executes that closure on every single element of the array,

610
00:33:18,920 --> 00:33:19,820
and it includes the ones

611
00:33:19,820 --> 00:33:23,390
where you return true from your closure. And it excludes

612
00:33:23,390 --> 00:33:26,590
the ones you don't, until filter returns a new array,

613
00:33:26,590 --> 00:33:30,800
which is only the things that match your closure, okay? So

614
00:33:30,800 --> 00:33:33,670
here for example, let bigNumbers = this

615
00:33:33,670 --> 00:33:36,840
array.filter, here's my closure,

616
00:33:36,840 --> 00:33:40,640
$0 is this thing that's gonna be for each of these,

617
00:33:40,640 --> 00:33:42,880
called on each of these. If $0 is greater than 20,

618
00:33:42,880 --> 00:33:47,280
I'm gonna return true. So this returns an array, bigNumbers,

619
00:33:47,280 --> 00:33:51,380
that only has 47 and 118, cuz those are the only

620
00:33:51,390 --> 00:33:54,550
two things greater than 20, got it? Okay,

621
00:33:54,560 --> 00:33:57,520
there's another one simpler, similar, which is map.

622
00:33:57,530 --> 00:34:01,890
Map takes your closure and your closure converts each

623
00:34:01,900 --> 00:34:04,860
element in the array to something else.

624
00:34:04,870 --> 00:34:07,400
So if you had an array of ints and you wanted it

625
00:34:07,400 --> 00:34:10,370
to be an array of strings, you could do it with this,

626
00:34:10,370 --> 00:34:14,470
okay map, closure. Notice, by the way,

627
00:34:14,480 --> 00:34:16,880
no parentheses here. You see, map, okay,

628
00:34:16,880 --> 00:34:21,050
map takes an argument, which is a closure there. But I have

629
00:34:21,050 --> 00:34:23,980
no parentheses after map around the curly braces like I

630
00:34:23,990 --> 00:34:27,690
had up here with filter. I put this in here to show you that

631
00:34:27,690 --> 00:34:30,720
those parentheses are optional when a closure

632
00:34:30,730 --> 00:34:33,290
is the last argument to a function, okay?

633
00:34:33,290 --> 00:34:36,230
When a closure is the last argument to the function,

634
00:34:36,230 --> 00:34:40,000
it can be outside of the function's parentheses, okay,

635
00:34:40,000 --> 00:34:41,230
and live on its own out here.

636
00:34:41,240 --> 00:34:45,140
Okay, here's another function, okay, called reduce.

637
00:34:45,140 --> 00:34:49,680
This reduces the array to a single result. Okay, so

638
00:34:49,680 --> 00:34:52,810
this particular one, you can convince yourself of it later,

639
00:34:52,810 --> 00:34:55,180
it adds up the numbers, okay. It just reduces,

640
00:34:55,180 --> 00:34:58,620
starts with zero, and for each one it takes the amount so

641
00:34:58,620 --> 00:35:01,620
far and adds it to the next thing in there, so

642
00:35:01,620 --> 00:35:03,260
it adds up the numbers.

643
00:35:03,260 --> 00:35:05,120
Notice this one has two arguments,

644
00:35:05,130 --> 00:35:09,500
an initial and a closure. Okay, see this closure here,

645
00:35:09,500 --> 00:35:12,800
an initial? And notice the closure also is still living

646
00:35:12,800 --> 00:35:16,070
outside of the parentheses. The first argument is inside

647
00:35:16,070 --> 00:35:19,210
the parentheses, but the closure is living outside.

648
00:35:19,210 --> 00:35:20,370
This one had no first argument.

649
00:35:20,370 --> 00:35:23,440
It only had the closure, so it has no parentheses here. This

650
00:35:23,440 --> 00:35:28,180
one does, okay? This is called trailing closure syntax, and

651
00:35:28,180 --> 00:35:31,180
you almost always wanna use it, it looks really cool,

652
00:35:31,190 --> 00:35:35,890
reads really nicely. Okay, dictionary.

653
00:35:35,890 --> 00:35:38,460
All right, so dictionary, similar to array,

654
00:35:38,460 --> 00:35:40,530
it's just looking up keys and values.

655
00:35:40,530 --> 00:35:44,230
Again, we're gonna use this more informal kind of syntax,

656
00:35:44,230 --> 00:35:48,630
okay? [String:Int] means the type dictionary where

657
00:35:48,640 --> 00:35:53,110
the strings are keys and ints are values, all right?

658
00:35:53,110 --> 00:35:55,570
So if I have pac10teamRankings here, and

659
00:35:55,580 --> 00:35:59,580
I had Stanford at number 1, Cal number 10, and I let the,

660
00:35:59,580 --> 00:36:02,750
I guess it's Pac-12 now. I should update this,

661
00:36:02,750 --> 00:36:07,020
should't I? So, okay, Cal 12 and so if I say here, let

662
00:36:07,020 --> 00:36:10,890
ranking = pac10teamRankings ["Ohio State"],

663
00:36:10,890 --> 00:36:14,590
that's obviously, no Ohio State in the Pac-12.

664
00:36:14,600 --> 00:36:17,930
So the ranking here has to be an Int?, right, it's

665
00:36:17,930 --> 00:36:22,970
an optional Int, we already saw that in our, calculator.

666
00:36:22,970 --> 00:36:26,370
Okay, anytime you dereference a dictionary,

667
00:36:26,370 --> 00:36:29,980
it's gonna return an optional of whatever type is

668
00:36:29,980 --> 00:36:34,750
the dictionary's values are, okay? The way you enumerate

669
00:36:34,750 --> 00:36:38,920
through a dictionary is using a tuple, okay, for (key,

670
00:36:38,920 --> 00:36:42,620
value) in pac10teamRankings, inside here, key is

671
00:36:42,620 --> 00:36:45,320
gonna be the key. And here is gonna be the value for each of

672
00:36:45,330 --> 00:36:49,860
the things in the dictionary, okay? Pretty cool. And again,

673
00:36:49,860 --> 00:36:52,230
you could put under bar here if you just wanted the keys,

674
00:36:52,230 --> 00:36:57,100
or under bar here if you just wanted the values. All right,

675
00:36:57,100 --> 00:37:02,170
String. String is a little complicated in Swift because

676
00:37:02,180 --> 00:37:03,210
it's full Unicode.

677
00:37:03,210 --> 00:37:06,010
And I mean full Unicode. All right so,

678
00:37:06,010 --> 00:37:09,350
it supports all kinds of languages. Languages where

679
00:37:09,350 --> 00:37:13,590
one character might be many, many different codes, okay.

680
00:37:13,590 --> 00:37:18,620
So characters are no longer single codes anymore. Okay,

681
00:37:18,630 --> 00:37:20,790
so, that's why, when you index into a string,

682
00:37:20,800 --> 00:37:24,230
you're not indexing by ints. You're indexing by

683
00:37:24,230 --> 00:37:28,470
indexes that know how to move along in a string past things

684
00:37:28,470 --> 00:37:32,240
like emojis that might have multiple codes, okay?

685
00:37:32,240 --> 00:37:34,240
So you're gonna wanna read about this, so

686
00:37:34,240 --> 00:37:36,910
I'm not gonna cover it all in lecture here. But

687
00:37:36,910 --> 00:37:39,880
one interesting way to look at a string is by calling

688
00:37:39,880 --> 00:37:43,920
this, String.CharacterView, okay? If you call character

689
00:37:43,920 --> 00:37:46,820
view on a string, you'll get the characters

690
00:37:46,820 --> 00:37:50,590
in what looks like an array of character, okay? It looks like

691
00:37:50,590 --> 00:37:53,090
an array of characters, not actually array of character.

692
00:37:53,090 --> 00:37:57,130
It's a character view. But it can be indexed with ints,

693
00:37:57,130 --> 00:38:00,100
okay, and you can get at the characters. So that's one way.

694
00:38:00,100 --> 00:38:03,000
Another way, you can actually create an array,

695
00:38:03,000 --> 00:38:06,710
one of the initializers that array will take is a string,

696
00:38:06,710 --> 00:38:09,340
okay. And then it'll be an array of characters.

697
00:38:09,340 --> 00:38:11,940
Okay, not quite as efficient as this character view, but

698
00:38:11,950 --> 00:38:14,510
you could do it that way, especially with a long string,

699
00:38:14,520 --> 00:38:17,150
you probably might not wanna do that. Okay, but that's

700
00:38:17,150 --> 00:38:19,720
a little easier way to get at it, otherwise you have to

701
00:38:19,720 --> 00:38:23,220
understand what it says in the reading about string indexes,

702
00:38:23,220 --> 00:38:25,860
okay. String.index that class and

703
00:38:25,860 --> 00:38:29,060
how to use it to get things out of a string,

704
00:38:29,060 --> 00:38:34,130
okay? There are a lot of other cool methods in String,

705
00:38:34,140 --> 00:38:36,700
though, like hasPrefix will tell you whether one string

706
00:38:36,700 --> 00:38:40,040
has the prefix of another string. You can capitalize and

707
00:38:40,040 --> 00:38:43,110
lowercase and uppercase these strings.

708
00:38:43,110 --> 00:38:45,080
You can even do sophisticated things like,

709
00:38:45,080 --> 00:38:48,950
get me all the components in this string separated by

710
00:38:48,950 --> 00:38:48,980
this other string. So

711
00:38:48,980 --> 00:38:52,550
this is a method you send to a string. This might be a comma,

712
00:38:52,550 --> 00:38:56,460
let's say, and this, right here like this, and it will

713
00:38:56,460 --> 00:39:00,130
extract all the strings that are separated by a comma.

714
00:39:00,130 --> 00:39:03,360
Okay, kinda fun. So make sure you familiarize yourself with

715
00:39:03,360 --> 00:39:06,300
a lot of the methods in String so that you don't waste your

716
00:39:06,300 --> 00:39:09,230
time writing this method which already exists, okay, or

717
00:39:09,240 --> 00:39:14,070
similar methods like it. All right, other classes that

718
00:39:14,080 --> 00:39:18,310
are here that you have to think about. One is NSObject.

719
00:39:18,310 --> 00:39:23,250
This is the base class of all Objective-C classes, okay.

720
00:39:23,250 --> 00:39:26,850
Now, we know, in Swift, it doesn't have a mandatory base

721
00:39:26,850 --> 00:39:30,660
class, like CalculatorBrain, no superclass, okay.

722
00:39:30,660 --> 00:39:31,820
Perfectly legal in Swift. But

723
00:39:31,830 --> 00:39:35,890
all Objective-C ones have to be subclasses of NSObject.

724
00:39:35,900 --> 00:39:38,560
Now, there are some APIs, they're fairly rare and

725
00:39:38,570 --> 00:39:41,830
I'll tell you which ones they are when we get to them later

726
00:39:41,840 --> 00:39:45,300
in the quarter, that are Objective-C APIs, okay.

727
00:39:45,310 --> 00:39:46,670
And when you use them in Swift,

728
00:39:46,670 --> 00:39:50,180
you need to have a class that subclasses from NSObject. So

729
00:39:50,180 --> 00:39:53,550
in Swift, it's perfectly legal to subclass from NSObject,

730
00:39:53,550 --> 00:39:56,620
not required except for in these few cases I'm gonna talk

731
00:39:56,620 --> 00:39:59,690
about later in the quarter. But legal and it really won't

732
00:39:59,690 --> 00:40:02,650
hurt anything, so you could do it if you want. Some people

733
00:40:02,660 --> 00:40:04,620
just get in the habit of always sub-classing for

734
00:40:04,630 --> 00:40:07,130
NSObjects in Swift, if they're not sub-classing from

735
00:40:07,130 --> 00:40:10,400
something else, because why not, okay. Then their classes

736
00:40:10,400 --> 00:40:14,870
are always ready for whatever these weird old APIs are,

737
00:40:14,870 --> 00:40:19,140
okay? NSNumber, okay in Objective-C,

738
00:40:19,140 --> 00:40:23,110
there's no such things as well structs

739
00:40:23,110 --> 00:40:28,110
in Objective-C are not like structs in Swift.

740
00:40:28,120 --> 00:40:30,920
They're not this nice value type semantic thing.

741
00:40:30,920 --> 00:40:36,190
Okay, structs are more like C structs okay, so double and

742
00:40:36,190 --> 00:40:38,290
int, string, array,

743
00:40:38,290 --> 00:40:41,090
dictionary. In Objective-C these are classes.

744
00:40:41,100 --> 00:40:45,530
Okay, sorry, array and diction are classes.

745
00:40:45,530 --> 00:40:51,040
Double and int are C-double and int. Not even objects,

746
00:40:51,040 --> 00:40:53,540
okay? So that brings a problem in Objective-C,

747
00:40:53,540 --> 00:40:56,910
what if I wanna put a bunch of numbers into an array? Okay,

748
00:40:56,910 --> 00:40:59,710
you can't do it, because an array is an array of objects.

749
00:40:59,710 --> 00:41:03,020
And doubles and ints are C primitive types,

750
00:41:03,020 --> 00:41:05,420
in Objective-C. So this class NSNumber,

751
00:41:05,420 --> 00:41:09,050
is how you wrap a primitive type into an object.

752
00:41:09,060 --> 00:41:09,350
So you can put it in an array.

753
00:41:09,360 --> 00:41:12,860
Now in Swift we don't need that, because in Swift arrays

754
00:41:12,860 --> 00:41:16,090
and dictionaries will accept structs, and double and

755
00:41:16,100 --> 00:41:20,570
int is a struct. Okay, so this NSNumber not necessary for

756
00:41:20,570 --> 00:41:26,040
that, okay. Now there are iOS APIs that take,

757
00:41:26,040 --> 00:41:29,710
for example, arrays of ints. And

758
00:41:29,710 --> 00:41:33,280
in Objective-C, they're gonna be arrays of NSNumber and

759
00:41:33,280 --> 00:41:37,520
in Swift, they're going to be Swift arrays of Swift Ints.

760
00:41:37,520 --> 00:41:39,450
And you might ask, how is that ever gonna work?

761
00:41:39,450 --> 00:41:41,920
Cuz you're talking about a struct filled with struct

762
00:41:41,920 --> 00:41:46,890
versus an array class filled with these NSNumber classes.

763
00:41:46,890 --> 00:41:49,830
Well the answer is, those things, array, dictionary,

764
00:41:49,830 --> 00:41:54,770
then int double, and NSNumber are all bridged, magically and

765
00:41:54,770 --> 00:41:58,070
automatically, okay? As you call functions that require

766
00:41:58,070 --> 00:42:00,410
one to be one way or the other. It just automatically

767
00:42:00,410 --> 00:42:03,840
works. Okay, there's a lot of magic going on in Objective-C

768
00:42:03,840 --> 00:42:06,140
runtime to make that work. Okay, and we're gonna take

769
00:42:06,150 --> 00:42:10,180
advantage of that bridging in a couple of slides here.

770
00:42:10,180 --> 00:42:13,720
NSDate, brilliant important class to know about. If

771
00:42:13,720 --> 00:42:17,020
you wanna put a date in your UI, you need be very careful.

772
00:42:17,020 --> 00:42:19,660
Because dates are represented in a different way all over

773
00:42:19,660 --> 00:42:25,300
the Earth. Date date class knows all about those ways and

774
00:42:25,300 --> 00:42:28,670
it has a lot of companion classes like NSCalendar,

775
00:42:28,670 --> 00:42:31,670
NSDateFormatter, NSDateComponents to help you

776
00:42:31,670 --> 00:42:35,040
put dates on screen in a way that's gonna work when you

777
00:42:35,040 --> 00:42:39,580
translate your app to Chinese. So NSDate is an important

778
00:42:39,580 --> 00:42:43,050
class to get familiar with and understand what it can do.

779
00:42:43,050 --> 00:42:45,320
Okay, if you're ever gonna put a date in your UI,

780
00:42:45,320 --> 00:42:48,550
you're gonna need to know about NSDate. NSDate can also

781
00:42:48,560 --> 00:42:52,790
tell you the current date and time. All right NSData,

782
00:42:52,790 --> 00:42:57,530
that's a bag of bits. Okay just unstructured bag o' bits.

783
00:42:57,530 --> 00:42:59,600
We use it to pass things around,

784
00:42:59,600 --> 00:43:01,930
sometimes over the network like image data,

785
00:43:01,940 --> 00:43:04,700
things like that. It's pretty self explanatory,

786
00:43:04,710 --> 00:43:06,200
bag of bits doesn't have a lot of methods on it.

787
00:43:06,210 --> 00:43:09,980
It's basically just give me the bits and here's some bits.

788
00:43:10,210 --> 00:43:13,110
Okay, now let's talk about initialization, I'm gonna kind

789
00:43:13,110 --> 00:43:16,250
of blast through this pretty quick. There's a really

790
00:43:16,250 --> 00:43:19,120
good explanation of this in your homework in your reading

791
00:43:19,120 --> 00:43:23,090
assignment. For this coming week but I'm gonna try and

792
00:43:23,090 --> 00:43:25,720
give you the 50,000 foot overview of it quickly so

793
00:43:25,730 --> 00:43:28,290
that you kind of have an idea what's going on as you go and

794
00:43:28,300 --> 00:43:31,400
read that very detailed description, okay?

795
00:43:31,400 --> 00:43:35,330
So when is an init method needed? We're talking about

796
00:43:35,340 --> 00:43:39,840
initializing structs and classes okay? They're

797
00:43:39,840 --> 00:43:42,370
not needed that often because of course we can say equal

798
00:43:42,380 --> 00:43:45,410
something in the var. We coud use those lazy instantiation

799
00:43:45,410 --> 00:43:49,010
things to get around it. Properties might be optional,

800
00:43:49,020 --> 00:43:50,780
so, and they can just start off being not set.

801
00:43:50,780 --> 00:43:53,850
So there's a lot of reasons you don't need an init, okay?

802
00:43:53,850 --> 00:43:56,720
And frankly, most people try to design their classes and

803
00:43:56,720 --> 00:43:59,790
structs so they don't need an init, okay? So you can just

804
00:43:59,790 --> 00:44:01,690
create them with an init with no arguments, right,

805
00:44:01,700 --> 00:44:05,160
which you get for free. Or a string in a struct case maybe

806
00:44:05,170 --> 00:44:08,370
you just do what we did in demo where you just init it

807
00:44:08,370 --> 00:44:11,870
with the values of all the things in the struct, okay?

808
00:44:11,870 --> 00:44:15,110
So but sometimes you might find yourself needing an init

809
00:44:15,110 --> 00:44:18,140
because you just can initialize things using those

810
00:44:18,150 --> 00:44:21,710
mechanisms, all right? Now, you do get some free inits,

811
00:44:21,720 --> 00:44:24,220
okay? We know about in classes you get the init with no

812
00:44:24,220 --> 00:44:27,450
arguments for free. That's how CalculatorBrain got an init,

813
00:44:27,450 --> 00:44:29,190
so we could create one. And

814
00:44:29,190 --> 00:44:30,560
we also know that structs have a free

815
00:44:30,560 --> 00:44:33,130
initializer to let you initialize all of the,

816
00:44:33,130 --> 00:44:38,500
all of its vars. Now, One thing to know about,

817
00:44:38,500 --> 00:44:41,230
[COUGH] both of those cases is that you,

818
00:44:41,240 --> 00:44:44,740
if you start providing your own initializers,

819
00:44:44,740 --> 00:44:47,740
then you stop getting the free one, okay?

820
00:44:47,740 --> 00:44:50,840
If you provide even one initializer for your struct

821
00:44:50,840 --> 00:44:54,450
you no longer get this free one, the one that does both,

822
00:44:54,450 --> 00:44:58,920
okay? All right, what can you do inside of init?

823
00:44:58,920 --> 00:45:02,820
What is legal to do? You can set any property's value,

824
00:45:02,820 --> 00:45:05,490
even one's that already have default values.

825
00:45:05,490 --> 00:45:06,490
Ones that you said equal something,

826
00:45:06,490 --> 00:45:08,630
you can reset them to something else if you want.

827
00:45:08,630 --> 00:45:09,590
You can set any property's value,

828
00:45:09,600 --> 00:45:13,670
okay. You can even set constant properties, okay.

829
00:45:13,670 --> 00:45:16,970
So if you have let something, so you have a constant in your

830
00:45:16,970 --> 00:45:20,070
class, like a constant instance variable basically.

831
00:45:20,070 --> 00:45:22,410
You can set that in, even though it's let,

832
00:45:22,410 --> 00:45:24,980
you can set it in the initializer. Constant

833
00:45:24,980 --> 00:45:27,850
properties are fairly rare. You know, why would you have

834
00:45:27,850 --> 00:45:30,550
something that's constant? You might, though, you might have

835
00:45:30,550 --> 00:45:33,550
something that's determined in initialization. And

836
00:45:33,550 --> 00:45:33,990
then it never changes,

837
00:45:33,990 --> 00:45:38,560
okay? You can call other init methods from your init,

838
00:45:38,560 --> 00:45:42,830
you actually can call one other init method from n init,

839
00:45:42,830 --> 00:45:47,600
okay? And you can call superclass inits, okay.

840
00:45:47,600 --> 00:45:50,000
You can call your superclass initializers, but

841
00:45:50,000 --> 00:45:52,740
there are rules for calling inits and they are rather

842
00:45:52,740 --> 00:45:54,970
complicated. And I'm gonna go through them quick and

843
00:45:54,980 --> 00:45:56,110
you're gonna read the documentations,

844
00:45:56,110 --> 00:45:58,110
it's gonna give you all the details, okay? So

845
00:45:58,110 --> 00:46:01,880
there are requirements inside of init, things you must do.

846
00:46:01,880 --> 00:46:03,750
The previous slide was things you are allowed to do,

847
00:46:03,750 --> 00:46:07,550
here's the things you must do, okay? By the time any init is

848
00:46:07,550 --> 00:46:10,420
done, okay? By the time the init is finished,

849
00:46:10,420 --> 00:46:13,590
all properties must have values. We know this, right?

850
00:46:13,590 --> 00:46:16,630
But in Swift, all, by the time initialization is done,

851
00:46:16,630 --> 00:46:19,300
all properties have to have values, and again,

852
00:46:19,300 --> 00:46:20,870
optionals must have a value too, but

853
00:46:20,870 --> 00:46:25,340
it could be the value not set. That's fine, okay? Now,

854
00:46:25,340 --> 00:46:30,180
there are two types of init methods in a class.

855
00:46:30,180 --> 00:46:34,110
Convenience methods and, convenience initializers and

856
00:46:34,110 --> 00:46:37,280
designated initializers. Designated initializers

857
00:46:37,280 --> 00:46:40,590
are not marked with the word convenience. Okay,

858
00:46:40,590 --> 00:46:43,390
convenience initializers say convenience init whatever,

859
00:46:43,390 --> 00:46:48,890
okay, in their declaration. A designated initializer must,

860
00:46:48,900 --> 00:46:52,130
and can only, call a designated initializers

861
00:46:52,130 --> 00:46:55,270
in it's superclass, its immediate superclass, okay?

862
00:46:55,270 --> 00:46:57,900
So a designated initializer can't call a convenience

863
00:46:57,910 --> 00:46:59,810
initializer in its superclass, and it can't

864
00:46:59,810 --> 00:47:02,740
call a convenience super, initializers in its own class.

865
00:47:02,740 --> 00:47:05,980
It must call a superclass's designated initializer. Okay,

866
00:47:05,980 --> 00:47:10,880
you must initialize all the properties that you introduce

867
00:47:10,880 --> 00:47:16,090
in your class, before calling a superclass's init.

868
00:47:16,090 --> 00:47:19,760
Okay, so by the time you call super init to let your super

869
00:47:19,760 --> 00:47:22,460
class initialize you must have all your properties

870
00:47:22,460 --> 00:47:27,700
initialized, all right? You must call a superclass's init

871
00:47:27,700 --> 00:47:32,370
before you can touch any of your superclass's properties.

872
00:47:32,370 --> 00:47:35,270
See the order there? You do yours, call the super,

873
00:47:35,280 --> 00:47:37,740
now you can touch theirs, okay? That makes sense.

874
00:47:37,740 --> 00:47:40,380
You gotta let them initialize theirs before you can touch it

875
00:47:40,380 --> 00:47:42,880
and you want yours initialized before they come along and

876
00:47:42,880 --> 00:47:46,850
start doing their stuff. A convenience initializer must

877
00:47:46,850 --> 00:47:52,260
and can only call an init, either can be user designated,

878
00:47:52,260 --> 00:47:55,730
in its own class, cannot call super. Okay,

879
00:47:55,730 --> 00:47:58,130
a convenience initializer cannot call super initializer.

880
00:47:58,130 --> 00:48:03,030
A convenience initializer must call that in it, before it can

881
00:48:03,040 --> 00:48:07,970
set any property values. It's own, or it's super classes.

882
00:48:07,980 --> 00:48:11,840
Okay, in other words, it must let a designated initializer

883
00:48:11,850 --> 00:48:14,550
initialize your own properties first.

884
00:48:14,550 --> 00:48:16,080
And that thing is gonna call supern,

885
00:48:16,080 --> 00:48:18,820
it's gonna initialize it, so by the time a convenience

886
00:48:18,820 --> 00:48:21,990
intializer gets back from the emit, all the property values

887
00:48:21,990 --> 00:48:24,590
will be set and it can reset them to something else,

888
00:48:24,590 --> 00:48:29,730
okay. It's just a convenience. Calling other inits

889
00:48:29,730 --> 00:48:33,470
has to be complete before you can access any properties.

890
00:48:33,470 --> 00:48:36,700
Access I'm talking about, not set. Access any properties or

891
00:48:36,700 --> 00:48:40,810
methods in yourself. So you can't say self.anything.

892
00:48:40,810 --> 00:48:43,440
You know, you can't access any of the properties or

893
00:48:43,440 --> 00:48:45,980
methods in yourself until you're fully initialized.

894
00:48:45,980 --> 00:48:49,110
Okay, so you'll have to have called the other inits first.

895
00:48:49,120 --> 00:48:51,920
Yeah? >> If you're building

896
00:48:52,620 --> 00:48:53,820
an imperative class why would you

897
00:48:53,820 --> 00:48:54,890
ever need convenience inits? >> So

898
00:48:54,890 --> 00:48:57,690
the question is why would I ever use a convenience init?

899
00:48:57,690 --> 00:49:02,190
The answer is I have a reasonable default for

900
00:49:02,200 --> 00:49:06,560
some of the arguments to a designated initializer, and

901
00:49:06,570 --> 00:49:08,800
it's actually possible to default things in swift.

902
00:49:08,800 --> 00:49:12,040
You can basically say, equal something. But let's say you

903
00:49:12,040 --> 00:49:15,010
wanna default into some calculative value, maybe based

904
00:49:15,010 --> 00:49:17,080
on the other argument. A community initialize,

905
00:49:17,080 --> 00:49:20,150
initializer you could create would have fewer arguments and

906
00:49:20,150 --> 00:49:22,510
then turn around and call the designated one.

907
00:49:22,520 --> 00:49:24,420
Okay, it's truly for convenience,

908
00:49:24,420 --> 00:49:26,950
that's all these are for, phew is right, okay.

909
00:49:26,950 --> 00:49:29,790
There's a lot of rules there. And it's a lot to think about.

910
00:49:29,790 --> 00:49:31,620
And when you start writing your own initializers you're

911
00:49:31,630 --> 00:49:33,060
gonna bump up against these all the time.

912
00:49:33,060 --> 00:49:36,190
You're gonna be like I can't, I can't access that one until

913
00:49:36,200 --> 00:49:38,900
I do, yeah, I gotta call supren, okay, believe me.

914
00:49:38,900 --> 00:49:41,030
So try to stay away from doing your own inits,

915
00:49:41,030 --> 00:49:45,040
is my advice to you. Okay, inheriting init.

916
00:49:45,040 --> 00:49:48,440
Now, if you don't implement any designated inits,

917
00:49:48,440 --> 00:49:51,280
you'll inherit all of your superclass's designated inits.

918
00:49:51,280 --> 00:49:53,980
But if you in, if you implement even one designated

919
00:49:53,980 --> 00:49:56,510
init, you don't get any of your superclass's designated

920
00:49:56,520 --> 00:50:01,950
initializers, okay. If you override all of your desig,

921
00:50:01,960 --> 00:50:04,360
class, superclass's designated inits, or

922
00:50:04,360 --> 00:50:07,130
don't implement any of them, then you will inherit all of

923
00:50:07,130 --> 00:50:12,100
the convenience initializers from your superclass, okay. In

924
00:50:12,100 --> 00:50:13,870
other words, the convenience superv, initializers in your

925
00:50:13,870 --> 00:50:17,570
superclass are all kinda dependent on the designated

926
00:50:17,570 --> 00:50:19,840
initializer in your superclass being sensible and

927
00:50:19,840 --> 00:50:23,380
making sense together. So you have to get them all

928
00:50:23,380 --> 00:50:27,410
by overriding them all, or by overriding none of them. For

929
00:50:27,410 --> 00:50:29,010
the convenience one to inherit,

930
00:50:29,020 --> 00:50:33,280
to make, for sure make sense, okay. If you omit no inits,

931
00:50:33,290 --> 00:50:36,220
you get all of your superclasses inits,

932
00:50:36,220 --> 00:50:40,030
convenience and designated, okay. Any in it that

933
00:50:40,030 --> 00:50:44,260
you inherit by these rules count on the previous slide.

934
00:50:44,260 --> 00:50:47,730
All right, the previous slide says things like you have to,

935
00:50:47,730 --> 00:50:50,870
convenience has to call a designated in your own class,

936
00:50:50,870 --> 00:50:53,270
blah, blah, blah. Well, if you inherit it,

937
00:50:53,270 --> 00:50:56,810
then it is in your own class. Okay, so

938
00:50:56,810 --> 00:51:03,010
chew on that okay. Required init, different topic.

939
00:51:03,020 --> 00:51:06,580
It is possible to mark an init with the keyword required.

940
00:51:06,590 --> 00:51:12,360
That means that a subclass must implement this init.

941
00:51:12,360 --> 00:51:14,460
Okay, it is not optional for it, it must.

942
00:51:14,460 --> 00:51:18,960
And it can inherit if it follows these rules above.

943
00:51:18,970 --> 00:51:23,570
But it must implement it, it's required, okay. UI view, for

944
00:51:23,570 --> 00:51:25,540
example, which we're gonna do on Wednesday.

945
00:51:25,540 --> 00:51:26,100
It has a required init.

946
00:51:26,110 --> 00:51:29,340
Okay, and we're gonna see that. All right,

947
00:51:29,340 --> 00:51:32,440
failable initializers, it is possible for init to fail.

948
00:51:32,450 --> 00:51:36,180
We saw this double if you pass a string to the initialize,

949
00:51:36,180 --> 00:51:38,720
if a double has an initializer it takes a string.

950
00:51:38,720 --> 00:51:41,590
If you pass a string. That's not a double,

951
00:51:41,590 --> 00:51:44,060
then it will fail, then return nil, okay.

952
00:51:44,060 --> 00:51:47,730
So failable initializers cause optional versions of the thing

953
00:51:47,730 --> 00:51:50,760
to be returned and you specify them with this little question

954
00:51:50,760 --> 00:51:54,330
mark. You put in a question mark in there, that turns

955
00:51:54,330 --> 00:51:57,670
this ititializer into the kind of initializer that will turn

956
00:51:57,670 --> 00:52:02,840
an optional of this class whatever it is. Okay? And

957
00:52:02,840 --> 00:52:06,280
to fail, you just return nil. Inside this initializer,

958
00:52:06,280 --> 00:52:09,480
if something goes wrong, return nil, and nil will come

959
00:52:09,480 --> 00:52:13,890
back to whoever's trying to get this thing. Make sense?

960
00:52:13,890 --> 00:52:17,690
Okay, failable initializers are pretty rare. Images, for

961
00:52:17,690 --> 00:52:18,090
example, UI image,

962
00:52:18,090 --> 00:52:20,860
image named, if it can't find an image with this name,

963
00:52:20,860 --> 00:52:23,960
it returns nil. Okay. So that's why this image right

964
00:52:23,960 --> 00:52:28,900
here Let image. This image is an Optional UIimage. And

965
00:52:28,900 --> 00:52:31,700
we probably use if-let here, if let image if we can like

966
00:52:31,710 --> 00:52:35,840
this image equal to UIimage name foo, then whatever.

967
00:52:36,940 --> 00:52:41,350
Okay? All right. Creating Objects All right,

968
00:52:41,350 --> 00:52:45,120
usually you create an object by calling its initializer

969
00:52:45,120 --> 00:52:49,250
with the appropriate arguments using the type name. So

970
00:52:49,260 --> 00:52:50,920
CalculatorBrain, we've seen that,

971
00:52:50,920 --> 00:52:54,590
ComplicatedObject with a bunch of arguments to create it.

972
00:52:54,590 --> 00:53:00,670
Or here's let z = the type array of String initializer.

973
00:53:00,670 --> 00:53:03,000
Okay, that creates an empty array of string.

974
00:53:03,000 --> 00:53:08,210
It's constant, so it's gonna be empty forever, okay? But

975
00:53:08,210 --> 00:53:11,240
sometimes other objects will create objects for you.

976
00:53:11,240 --> 00:53:14,180
They can call a method and it will create an object for you,

977
00:53:14,180 --> 00:53:14,810
give it to you, right? But

978
00:53:14,810 --> 00:53:18,980
when you're creating objects from scratch, this is the.

979
00:53:18,990 --> 00:53:20,590
Syntax you're using, you're used to that, right?

980
00:53:20,590 --> 00:53:25,990
No questions about that, it's a kind of obvious slide. Okay,

981
00:53:25,990 --> 00:53:28,990
now AnyObject, little more complicated here.

982
00:53:29,000 --> 00:53:32,630
AnyObject is a special type, it's actually a protocol, but

983
00:53:32,630 --> 00:53:33,900
we haven't talked about it yet, but anyway,

984
00:53:33,900 --> 00:53:36,100
it's a special type. You can leave it as a type.

985
00:53:36,100 --> 00:53:40,610
Protocols are types, I guess. It is used Commonly, or used,

986
00:53:40,610 --> 00:53:43,910
used to be, for compatibility with Objective-C APIs,

987
00:53:43,910 --> 00:53:47,450
because Objective-C, for those of you who are trying to learn

988
00:53:47,450 --> 00:53:50,520
some Objective-C along the way here, Objective-C has a very

989
00:53:50,520 --> 00:53:54,720
important type called ID. Okay, the type ID.

990
00:53:54,720 --> 00:54:00,560
Which means pointer to a object of unknown class.

991
00:54:00,560 --> 00:54:04,200
Okay. So that's a very open-ended type. [LAUGH] Okay,

992
00:54:04,200 --> 00:54:07,400
Swyft doesn't do things that way. Swyft is strongly typed.

993
00:54:07,400 --> 00:54:12,140
Okay, it infers types but it's strongly typed. However,

994
00:54:12,140 --> 00:54:15,310
Swyft has to work with all those IOSAPIs, so

995
00:54:15,310 --> 00:54:17,080
it introduced this type called AnyObject.

996
00:54:17,080 --> 00:54:21,680
So AnyObject in Swyft means A point or two an object of

997
00:54:21,680 --> 00:54:24,680
unknown class, okay? It only works for objects for

998
00:54:24,680 --> 00:54:29,350
classes not for. So it means the same thing as objective C.

999
00:54:29,360 --> 00:54:33,560
IN iOS 9 they fixed objective C. So it has almost none of

1000
00:54:33,560 --> 00:54:38,530
these, okay? They're still a few but very very few. So
移除了旧的实现。 但是在少数代码中还是存在的。

1001
00:54:38,530 --> 00:54:42,630
nowadays It is more used as an opaque type. Okay?
现在 AnyObject 主要用于需要隐藏具体细节的类型的场景。

1002
00:54:42,640 --> 00:54:43,400
When you want to have a point or
当你希望有一个指针指向

1003
00:54:43,400 --> 00:54:45,970
two in the object and you are not sure what it is or
一个对象，并且你不确定这个对象是什么你不希望让别人知道

1004
00:54:45,970 --> 00:54:48,370
you don't want anyone to know what it is okay?
这个对象具体是什么的时候，可以考虑用 AnyObject

1005
00:54:48,380 --> 00:54:52,510
So let's talk about how we can do this okay? So classes only
那么我们可以如何使用 AnyObject 这个类型呢？它只能用于 Class 类型的

1006
00:54:52,510 --> 00:54:55,680
and no structs. There is another type by the way. It is
对象，而不能使用在 Struct 的对象上。 这里顺带提一句， 还有另外一种类型。

1007
00:54:55,680 --> 00:55:00,080
what is called any, which is anything. Could be a struct,
叫做 Any， 他能指向任何类型的对象， 可以指向 Struct、

1008
00:55:00,090 --> 00:55:02,990
could be a class, anything. We almost, in fact, this class we
Class 以及其他所有类型的对象。 事实上，我们基本上

1009
00:55:02,990 --> 00:55:06,220
will never use Any, okay? You probably never wanna use it.
不会用到 Any 这个类型。 你也不会想要使用它。

1010
00:55:06,230 --> 00:55:08,930
It's in there, I think, for just language completeness.
它存在的意义就在于保证语法的完整性。

1011
00:55:08,930 --> 00:55:12,130
But I can't even think of a good explanation of why you
但是我完全无法想到你能使用到它的场景。

1012
00:55:12,130 --> 00:55:15,170
would wanna use it. So we're not even gonna talk about Any.
所以我们这就不讨论 Any 。

1013
00:55:15,170 --> 00:55:17,040
But we are gonna talk about AnyObject, okay?
我们还是继续讨论 AnyObject 吧。

1014
00:55:17,040 --> 00:55:19,270
So where will you see AnyObject? You'll sometimes
想想你们都在哪见过 AnyObject ？

1015
00:55:19,270 --> 00:55:23,640
see it in a method where one of the arguments Truly can be
你应该在在一些参数可能是多种类型的

1016
00:55:23,640 --> 00:55:26,340
more than one different kinds of class, mm kay? For
方法中看到它对吧？

1017
00:55:26,350 --> 00:55:29,310
example, you'll see on Wednesday, prepare for segue
例如将在下周三的课上才讲到的在MVC

1018
00:55:29,320 --> 00:55:33,120
which is a thing that prepares for transitions from one NVC
跳转前会调用 prepareForSegue 方法中含有 AnyObject 的参数。

1019
00:55:33,120 --> 00:55:36,590
to another, okay? We're gonna have multiple NVCs someday.
我们会在一个项目中含有非常多的 MVC 。

1020
00:55:36,590 --> 00:55:38,690
We're gonna wanna transition from one to the other, prepare
我们经常会从一个跳转到另一个过程，

1021
00:55:38,690 --> 00:55:41,660
for segue prepares for that transition. Well the sender,
而 prepareForSegue 则是为了这种跳转而存在的。 至于该方法的参数 sender，

1022
00:55:41,660 --> 00:55:45,100
in other words the object that initiated the transition could
换句话来说，这个对象用来初始化跳转，并且它包含

1023
00:55:45,100 --> 00:55:47,100
be lots of different kinds of objects.
许多不同的类型的对象。

1024
00:55:47,100 --> 00:55:48,430
It might be a button you collect on,
他可能是一个按钮

1025
00:55:48,440 --> 00:55:51,200
it might be a roll in a table, it might be some custom code
他可能是一个一个在列表中的滚动条， 它可能是一段在你的 Controller 中自定义的代码。

1026
00:55:51,200 --> 00:55:55,240
inside of your controller. Okay? So this sender has to be
所以这个 sender 参数必须使用 AnyObject 类型。

1027
00:55:55,240 --> 00:55:59,840
any object. Okay, cuz we don't know what it is. We
因为我们不知道具体情况下，它是什么？

1028
00:55:59,850 --> 00:56:03,410
don't know if it is a button or table row or what it is.
我们不知道它是否是一个按钮、列表或者是其他什么东西。

1029
00:56:03,420 --> 00:56:06,580
So AnyObject. Okay. So this is a case where he is an object,
因此最好使用 AnyObject。 这就是一个对象使用 AnyObject 的例子，

1030
00:56:06,590 --> 00:56:09,650
it could be many things we don't know what it is.
他可能是非常多类型的对象， 而我们不知道它具体是什么。

1031
00:56:09,660 --> 00:56:12,060
So we have to type this as AnyObject.
所以我们这里必须使用 AnyObject 类型。

1032
00:56:12,060 --> 00:56:15,930
Okay? Another example of that is touch digit. If we haven't,
另外一个例子就是之前用到的 touchDigit 方法。

1033
00:56:15,930 --> 00:56:16,630
when we control dragged,
如果在我们拖拽链接中，

1034
00:56:16,630 --> 00:56:19,630
remember when we changed it from any object to UI button,
忘记了从 AnyObject 改成 UIButton 的情况下。

1035
00:56:19,630 --> 00:56:22,200
Okay. If we hadn't done that, it would have created a touch
如果我们忘记了修改， 他将会创建一个 touchDigit 方法，

1036
00:56:22,200 --> 00:56:25,170
digit with sender AnyObject and then touch digit could've
该方法带有一个 AnyObject 类型的 sender 参数， 这样 touchDigit 方法

1037
00:56:25,170 --> 00:56:29,140
been sent by a UI button or maybe by UI slider. Okay. Or
可能由一个 UIButton 触发或者是 UISlider 触发。

1038
00:56:29,140 --> 00:56:32,710
something else. And we didn't do that because the inside
当时我们当时并没有用 AnyObject 类型的参数是因为

1039
00:56:32,710 --> 00:56:34,910
touch digit we wanted sender to be a UI button so
我们希望触发 touchDigit 放的的对象是 UIButton 的类型。

1040
00:56:34,910 --> 00:56:38,920
we just send it current title and other button things, but
这样我们就可以获得他的内容以及一些其他按钮的属性或方法，

1041
00:56:38,920 --> 00:56:43,820
it could have been AnyObject, all right? So, another use for
但是其实它还是可以改成 AnyObject。

1042
00:56:43,820 --> 00:56:46,690
AnyObject is when you wanna return essentially a cookie,
当时想要用一个密封的 Cookie 的时候， 你也可以用 AnyObject 类型。

1043
00:56:46,690 --> 00:56:49,290
okay? A cookie is something
Cookie 是一个

1044
00:56:49,300 --> 00:56:52,230
you give back where you're giving it to someone,
你给一个指定的人

1045
00:56:52,230 --> 00:56:53,360
they don't know what's inside of it,
但是他们不需要知道它里面的内容，

1046
00:56:53,370 --> 00:56:56,100
you're not gonna tell them, the only thing they can do
你也不希望告诉他们， 他们所要做的就是将它

1047
00:56:56,100 --> 00:57:00,340
is give it back to you, okay? So the cookie just saves some
再传递给你。 所有 Cookie 只是保存了一些

1048
00:57:00,340 --> 00:57:03,510
state, remembers something and you can give it back. So
状态， 或者是一些你能知道内部实现的东西。

1049
00:57:03,510 --> 00:57:06,540
browsers have cookies, right? You go visit a browser site,
因此浏览器有对应的 Cookie， 当你访问一个网站，

1050
00:57:06,550 --> 00:57:10,480
the site stores some stuff about itself and about you in
该网站会存储很多关于它的信息以及保存一些关于你信息

1051
00:57:10,480 --> 00:57:13,180
their cookie. When you go away and come back to that site,
的 Cookie。 当你离开这个网站的时候，这些 Cookie 会传回该网站，

1052
00:57:13,190 --> 00:57:15,590
it looks in the cookie and it can interpret it, okay?
如此看来的话， 该网站对 Cookie 应该是可理解的。

1053
00:57:15,590 --> 00:57:16,890
But it gives the cookie to the browser.
但是当将这个 Cookie 给浏览器时，

1054
00:57:16,890 --> 00:57:19,120
The browser has no idea what's in there. Okay.
浏览器完全无法知道它具体是什么内容。

1055
00:57:19,130 --> 00:57:23,530
To pick with AnyObject as far as the browser is concerned.
因此用 AnyObject 是浏览器最好的选择。

1056
00:57:23,530 --> 00:57:27,870
All right. So how do we use a variable type AnyObject when
那么我们如何使用一个 AnyObject 类型的对象， 并且

1057
00:57:27,870 --> 00:57:30,940
we don't know what the heck it is? Okay. And the answer is we
我们不知道它具体的内容？ 答案是

1058
00:57:30,940 --> 00:57:33,640
have to convert it to a type that we do know what it is.
我们必须将其转换成一个我们知道的类型。

1059
00:57:33,640 --> 00:57:36,970
Okay. Now this conversion might not be possible.
当然， 这种换换过程可能会失败，

1060
00:57:36,980 --> 00:57:40,310
All right, because that thing might not be of that type
因为在我们转换的过程中，

1061
00:57:40,310 --> 00:57:41,350
when we try to convert it. So
我们所转换的对象可能不是那种类型。

1062
00:57:41,350 --> 00:57:46,820
we use this as keyword in Swift to try to convert it to
因此我们在 Swift 中用一个关键字 as 尝试去

1063
00:57:46,820 --> 00:57:50,150
the other type. Okay. In other words, try to treat that
转换成其他类型。 也就是说， 你尝试将 AnyObject

1064
00:57:50,160 --> 00:57:54,990
AnyObject as something else, optionally. So this is an op,
转换成其他东西。 转换后

1065
00:57:54,990 --> 00:57:59,000
this returns an optional. Okay, we usually, usually use
返回的是 Optional 的类型。 我们经常用 if let 的方式

1066
00:57:59,000 --> 00:58:01,970
it with if let, this as thing because it ensure an optional,
因为用这个中法获得的一定是 Optaional 的类型。

1067
00:58:01,970 --> 00:58:04,670
right? So if I have this local variable here,
例如我这里有一个变量，

1068
00:58:04,670 --> 00:58:08,870
AO which is in AnyObject and I was tying it to something,
ao 是一个 AnyObject 类型， 并且我尝试将它转换成

1069
00:58:08,880 --> 00:58:12,280
some class I don't know what it is, okay? But I wanna try
其他类型, 并且我们不知道 ao 具体是什么类型。 但是这里我希望将其

1070
00:58:12,280 --> 00:58:17,420
and use AO as if it were of class SomeClass, okay,
换换成 SomeClass 这种类型。

1071
00:58:17,420 --> 00:58:20,180
AO might be of SomeClass, and I'm gonna see if it is, and
ao 可能是 SomeClass 这种类型， 那么如果它是的话，

1072
00:58:20,190 --> 00:58:23,890
if it is I'm gonna use it as some class, I say if I can let
我们将其转换成 SomeClass 并且使用它， 也就是说如果我能让 foo

1073
00:58:23,890 --> 00:58:28,990
foo equal AO as SomeClass, then in here there's gonna be
等于 ao 转换成 SomeClass 的对象不为空的话， 那么我这里将会等一个

1074
00:58:29,000 --> 00:58:32,530
a local variable foo, which is not gonna be AnyObject, it's
名为 foo 的本地变量， 并且 foo 将不再是 AnyObject 类型， 应该

1075
00:58:32,530 --> 00:58:38,240
gonna be of type SomeClass. Got it? Just to that symbol
是 SomeClass 类型。 明白了吗？ 使用这种方式

1076
00:58:38,240 --> 00:58:42,840
essentially casting if you wanna use that terminology?
将其转换成想要的类型。

1077
00:58:42,840 --> 00:58:46,940
Casting any object to be some class conditionally, okay?
使用 let if 这种方式将 AnyObject 转换成想要转换的类型即可。

1078
00:58:46,950 --> 00:58:51,420
So that's how we use something of AnyObject either that or
这就是我们如何使用 AnyObject 对象的方式， 或者是在我们

1079
00:58:51,420 --> 00:58:54,650
we don't know what's in there we just pass it around. Okay,
不青春它具体的内容是，而只是传递它时使用。

1080
00:58:54,650 --> 00:58:57,960
just pass it around to people who know what to do with it.
将其传递给真正知道它是什么内容的人。

1081
00:58:57,960 --> 00:59:02,660
We don't know what to do with it if it's a cookie, okay? So,
我们不知道一个 Cookie 具体能做什么。

1082
00:59:02,660 --> 00:59:05,400
what would code look like let's say on touchDigit.
那么如果 touchDigit 方法使用 AnyObject 参数该如何写？

1083
00:59:05,400 --> 00:59:08,870
If we had touchDigit and we had any object instead.
如果我们有一个 touchDigit 带有 AnyObject 的参数的话。

1084
00:59:08,870 --> 00:59:13,340
We probably say if we can let sendingButton equal the sender
我们可能会使用如果 sendingButton 等于 sender 转换成

1085
00:59:13,340 --> 00:59:16,240
as a UIbutton, then we'll treat it as a button,
UIButton 并且 sendingButton 不为空的话， 我们将其转换成，

1086
00:59:16,240 --> 00:59:19,410
get its currentTitle and go. Other wise else if
然后获得他的内容以及调用它的方法等。 另一方面， 如果

1087
00:59:19,410 --> 00:59:23,510
we can let sending slider equal to sender as UI slider,
能将其转换成 UISlider 并且不为空的话，

1088
00:59:23,520 --> 00:59:26,720
then we'll let the digit equal the sending sliders value
那么数字就等于 Slider 的值。

1089
00:59:26,720 --> 00:59:28,820
which is a double, we'll convert it to an int and
但是由于其实 Double 类型，所以我们需要将其转换成 Int

1090
00:59:28,820 --> 00:59:31,790
we'll convert that to a string, okay? That's how we
然后再转换成 String 类型。 这就是如何获得具体

1091
00:59:31,790 --> 00:59:35,660
get the digit. Did you see how we're doing kinda if let else,
数值的方式。 大家看清楚 if let 的方式

1092
00:59:35,660 --> 00:59:39,060
if let else? With this optional thing, that's how we
该如何操作了吗？ 这就是我们处理 AnyObject 的方式。

1093
00:59:39,070 --> 00:59:43,700
would use that AnyObject. All right, another use
还有一种使用 AnyOject 的场景就是

1094
00:59:43,700 --> 00:59:49,140
of AnyObject is Property List, okay? So Property Lists are,
用在 Property List 中。 因为 Property List 中可能包含

1095
00:59:49,140 --> 00:59:53,080
essentially any combination of array, dictionary, string,
数组、 字典、 字符串

1096
00:59:53,080 --> 00:59:57,080
double, int, NSData, and NSDate. Kay, if you build
Double、 Int、 NSData 甚至是 NSDate 类型的数据。

1097
00:59:57,080 --> 00:59:59,520
any data structure out of only those classes,
如果你使用这些类型来存储数据的话，

1098
00:59:59,520 --> 01:00:02,220
you got a property list. So it's just a word. It's just
那么你就能获得一个 Property List。 这就是我们

1099
01:00:02,220 --> 01:00:06,160
a term we use to mean that. Kay, that's what it means.
想要的类型。 这就是它的含义。

1100
01:00:06,160 --> 01:00:10,130
And you might feel like, wait a second. Array,
等等，或许你会想：

1101
01:00:10,130 --> 01:00:13,160
AnyObject has to be a class, it cannot be a structs.
AnyObject 是一个Class类型， 而不是 Struct 类型。

1102
01:00:13,170 --> 01:00:16,000
But string, array, dictionary, double, those are structs.
但是 String、 Array、 Dictionary、 Double 这些都是 Struct 类型。

1103
01:00:16,000 --> 01:00:18,740
So how could this ever be in a property list. How could it
那么他们如何包含在一个 Property List 中呢？

1104
01:00:18,740 --> 01:00:23,210
ever be any object. And the answer is the bridging, kay?
他们是如何转换成 AnyObject 类型呢？ 答案是桥接。

1105
01:00:23,210 --> 01:00:26,110
We got this automatic bridging to Objective-C, kay?
它们能自动转换成Objective C。

1106
01:00:26,110 --> 01:00:30,310
It automatically treats them like NSDictionary, NSArray,
它们会自动转换成 NSDictionary、 NSArray、

1107
01:00:30,320 --> 01:00:34,890
NSNumber, which are all classes. And allows them to be
NSNumber 或者是任何它们的封装类型。 这样就允许他们转换成 AnyObject了。

1108
01:00:34,890 --> 01:00:39,820
AnyObject, kay? Now these property lists
那么通过这种方式

1109
01:00:39,830 --> 01:00:43,560
are passed around blindly. The people who are looking in them
Property List 就在传递过程中可以不让人知道具体内容。 那么及时有人破解它的话，

1110
01:00:43,560 --> 01:00:46,730
are only knowing that their dictionaries and
他们也只能知道字典、数组

1111
01:00:46,730 --> 01:00:47,900
arrays of strings and dates and stuff.
字符串、日期以及一些其他的东西。

1112
01:00:47,900 --> 01:00:50,800
They don't know anything about what that data means, okay.
但是他们却不知道具体数据的含义。

1113
01:00:50,800 --> 01:00:52,600
They're just being passed around, so
那么它就可以被传递了。

1114
01:00:52,610 --> 01:00:55,010
let's look at an API and iOS that uses a property
那么让我们看看 iOS 中的一个 API， 一个便于

1115
01:00:55,010 --> 01:00:58,610
list to understand it better. It's called NSUserDefaults.
我们理解 Property List 的API。 那就是 NSUserDefaults。

1116
01:00:58,610 --> 01:01:02,110
What NSUserDefaults does, is it takes a property list and
那么 NSUserDefaults 是拿来干嘛的呢？ 它是用来缓存 Property List

1117
01:01:02,120 --> 01:01:05,550
makes it persistent on disk. So when your app quits and
并且将其保存到磁盘上的。 那么当你 App 退出重启后，

1118
01:01:05,550 --> 01:01:08,190
runs again and you look it up again, it's there.
你能从新查询到保存的数据， 因为它保存在磁盘了。

1119
01:01:08,190 --> 01:01:10,660
So it's basically a database of property lists,
它有点类似一个 Property List 的基础数据库，

1120
01:01:10,660 --> 01:01:14,830
a database of structures with dictionaries, arrays, dates,
一个包含字典，数组，日期的数据库。

1121
01:01:14,830 --> 01:01:17,060
okay, that's what it is.
这就是N SUserDefaults。

1122
01:01:17,060 --> 01:01:19,430
It's a small database so don't use it for big things.
由于它是一个微型数据库，所以我们一般用它来保存大的数据。

1123
01:01:19,430 --> 01:01:21,700
You wouldn't wanna store like a dictionary of the entire
例如你绝对不会想用它来保存

1124
01:01:21,700 --> 01:01:23,330
English language in there. It's for
所以英语的字典。

1125
01:01:23,340 --> 01:01:26,870
small things like settings and things like that. The API on
他只是用来存一些小东西，例如设置、配置等一些小的东西。

1126
01:01:26,870 --> 01:01:30,810
it is very simply just say, setObject, property list here,
并且它的接口也非常简单， 只需要调用 setObject 用来存 Property List,

1127
01:01:30,810 --> 01:01:33,710
forKey, string. And then you can look it up and
用 String 来存 Key。 这样你就可以通过

1128
01:01:33,710 --> 01:01:36,280
get the property list back. So here you can see how you're
get 方法重新获得具体的 Property List。 你可以看得出，这里你

1129
01:01:36,280 --> 01:01:39,450
just passing it around. You're storing it as a cookie and
只是负责传递给NSUserDefaults。 你想保存 Cookie 一样保存它，

1130
01:01:39,450 --> 01:01:41,750
it's user defaults has no idea what's inside there.
并且 NSUserDefaults 对于里面具体是什么完全不了解。

1131
01:01:41,750 --> 01:01:44,290
It just knows it's only array is dictionary strings,
它只知道他可能是数组、 字典、 字符串

1132
01:01:44,290 --> 01:01:48,830
ints, etc, okay. It can also restore smaller things.
数值等一些数据。 并且能通过它重新获得这些小数据。

1133
01:01:48,830 --> 01:01:51,130
Like as I said a double, and it will make a little property
例如我告诉它保存一个 Double， 那么他就会创建一个小的 Property List

1134
01:01:51,130 --> 01:01:54,300
list out of a double because a double by itself Is a property
用来保存 Double， 因为 Double 会是一个 Property List 类型。

1135
01:01:54,300 --> 01:01:58,200
list, right? Because it's one of those classes, okay?
它是一个 Class 的类型。

1136
01:01:58,200 --> 01:02:01,710
Just like array is. How do you use user defaults?
就像一个数组一样。 那么你是如何使用 NSUserDefaults 的呢？

1137
01:02:01,710 --> 01:02:06,810
You create a shared one using this class or type method,
你只需调用它的类方法，

1138
01:02:06,810 --> 01:02:08,980
NSUserDefaults.standardUserDe- faults().
一个叫 NSUserDefaults.standardUserDefaults() 的方法。

1139
01:02:08,980 --> 01:02:12,320
This gives you the shared instance of standard, of user
这个方法将会返回一个共享的 NSUserDefaults 对象。

1140
01:02:12,320 --> 01:02:17,320
defaults. And then you just say To it. Get me a certain
接下来你只需调用它的方法获得数据，或者

1141
01:02:17,320 --> 01:02:21,630
property list, write this property list out. The changes
将一些数据写入即可。

1142
01:02:21,630 --> 01:02:23,730
you make will automatically be saved eventually, but
这些改变将会自动的保存下来，

1143
01:02:23,730 --> 01:02:26,200
if you wanna force them to be saved on disk, you can do
但是如果你想强制将其保存到磁盘的话， 你可以调用

1144
01:02:26,200 --> 01:02:29,530
synchronize, which returns a bool, which we almost always
synchronize 这个方法， 这个方法返回一个布尔类型，

1145
01:02:29,540 --> 01:02:31,400
ignore because not clear what to do if it fails.
这个返回值经常被我们忽略， 因为我们并不清楚它做什么，并且是否失败。

1146
01:02:31,400 --> 01:02:33,900
It would probably only fail if your disk were full.
如果返回时的false的话， 则表示你的磁盘以满。

1147
01:02:33,910 --> 01:02:36,810
Not sure what you're gonna do at that point, but any way.
并且你不确定如果失败了你应该做什么。

1148
01:02:36,810 --> 01:02:41,710
We usually ignore that return value, okay? Another example
我们经常会忽略这个返回值。

1149
01:02:41,710 --> 01:02:45,250
of property list might be in our calculator brain and
另一个使用 Property List 的例子将会在我们的 CalculatorBrain中使用，

1150
01:02:45,250 --> 01:02:46,680
I'm gonna show you a demo of this.
我将会在接下来的Demo进行展示。

1151
01:02:46,690 --> 01:02:50,790
Really quick here, which is, what if we wanted to get
接下来会讲非常快，关于假如我们希望在计算器中

1152
01:02:50,790 --> 01:02:53,590
the program that it's in the calculator? Right now,
获得它之前的运算结果。

1153
01:02:53,590 --> 01:02:55,560
our calculator could be programmed by saying
现在的计算能可以计算出类似：

1154
01:02:55,560 --> 01:02:58,730
five times four times three equals, let's put a program
5 乘以 4 乘以 3 等于什么这种运算， 我们只需将具体

1155
01:02:58,730 --> 01:03:00,900
in the calculator, right? Five times four times three.
操作输入计算器中即可。 输入 5 * 4 * 3.

1156
01:03:00,900 --> 01:03:03,930
It's kinda simple program. It'd be cool if we get
这个是非常简单的运算， 那么如果计算器能

1157
01:03:03,940 --> 01:03:05,400
that program and the person who got it,
将这种与运算表达式交给一个完全

1158
01:03:05,400 --> 01:03:08,570
it doesn't know anything about our internal data structure.
不了解运算表达式内部实现的人，那肯定非常溜的功能。

1159
01:03:08,570 --> 01:03:10,940
So it's AnyObject to them. And then later,
那么这就可以用上 AnyObject了。

1160
01:03:10,940 --> 01:03:12,280
they could come back to the CalculatorBrain and
只需将重新传递运算表达式给 CalculatorBrain，

1161
01:03:12,280 --> 01:03:16,810
say. Run this program that you gave me earlier, you see? So
并且告诉它， 运行这些你之前给我的运算表达式， 这样就可以得到答案了。

1162
01:03:16,820 --> 01:03:19,920
we use AnyObject as kind of this opaque program.
因此我们在这里用 AnyObject 来代表一个不透明的运算表达式。

1163
01:03:19,920 --> 01:03:22,220
Okay. Now this doesn't seem very variable right now.
不过现在看起来好像不可以带参数的。

1164
01:03:22,220 --> 01:03:24,520
But it's gonna be really valuable in assignment two,
但是我们希望将其做成可带参数的，

1165
01:03:24,520 --> 01:03:27,730
when you're gonna add variables to your calculator.
之后只需将参数的具体值告诉给你的计算器即可。

1166
01:03:27,730 --> 01:03:31,130
You're gonna be able to say three times X times five
也许你希望保存表达式 3 * X * 5这种表达式，

1167
01:03:31,130 --> 01:03:32,900
equals, where X is a variable, and
其中 X 是一个变量，

1168
01:03:32,900 --> 01:03:36,370
then you can run this then you get this program using this
那么你可以使用我接下来

1169
01:03:36,370 --> 01:03:40,170
code I'm going to show you here, the property list, and
将要完成的代码， 并且在代码中使用 Property List，这样你

1170
01:03:40,170 --> 01:03:43,170
then later you can, they can set the variable x and
可以做到了， 你可以设置变量 X 的值，并且重新运行

1171
01:03:43,180 --> 01:03:45,940
run it again. Maybe set the x to something else and
具体的表达式。 可以设置 X 为任意的一个值，然后

1172
01:03:45,950 --> 01:03:47,680
run the program again and again and again, you see?
不断的重复运行这个表达式。

1173
01:03:47,680 --> 01:03:50,650
So this would be a good use of AnyObject, because
那么希望这样的话， 最好使用 AnyObject 类型，

1174
01:03:50,650 --> 01:03:54,150
the calculator brain doesn't wanna give away its internal
因为 CalculatorBrain 并不想泄露

1175
01:03:54,150 --> 01:03:57,090
data struc for how, structure for how it represents
他的类型以及它是如何

1176
01:03:57,090 --> 01:04:00,660
a program. But it's happy to let someone have the program
重新运算该表达式的。  但是可以让别人拥有该运算表达式，

1177
01:04:00,660 --> 01:04:04,660
and give it to them later and they'll run again it later.
并且将其重新交给计算器， 计算器将会重新计算该运算表达式。

1178
01:04:04,660 --> 01:04:06,000
Make sense, see why we want it?
这样就可以理解为什么使用 AnyObject 了吧？

1179
01:04:06,000 --> 01:04:07,830
Now why would we make it a property list?
那么我们这里为什么要用使用 Property List 呢？

1180
01:04:07,830 --> 01:04:10,870
Because it'd be nice to store it in user defaults, right?
因为这样方面将其存入到 NSUserDefaults 里。

1181
01:04:10,870 --> 01:04:13,200
I've got a program? I'm gonna put it in the user defaults.
当我获得一个表达式之后， 我将其保存在 NSUserDefaults 中。

1182
01:04:13,210 --> 01:04:15,440
Next time my program runs, I can pull it out and
当下次我的程序运行时， 我能从 NSUserDefaults 重新获得，

1183
01:04:15,440 --> 01:04:17,340
ask a calculator brain to run it. You see,
然后让 CalculatorBrain 重新运算它。

1184
01:04:17,340 --> 01:04:19,280
it's just more flexible to be a property list.
由此可以看出 Property List 相对比较灵活。

1185
01:04:19,280 --> 01:04:21,850
So that's what we're gonna do. We're gonna create a var
我们接下来就按照上面的方法来实现。 首先，我们在 CalculatorBrain 中先创建一个

1186
01:04:21,850 --> 01:04:23,510
called program in our calculator brain.
叫做 program 的的属性。

1187
01:04:23,520 --> 01:04:25,880
It's gonna be gettable and settable. When you get it,
并且给他添加 get 和 set 的方法。 当你获得它的值得时候，

1188
01:04:25,890 --> 01:04:29,420
it gets the current program in, that the calculator brain
他将会给出之前当前表达式， 之前计算过的表达式。

1189
01:04:29,420 --> 01:04:33,220
has just run, and if you set it, it runs the program, okay?
当时你设置它的值得时候， 该表达式会重新运算一遍。

1190
01:04:33,230 --> 01:04:35,660
All right, so I'm gonna do that as the demo. I'm gonna
好的，接下来我讲在我们的Demo上添加该功能。

1191
01:04:35,660 --> 01:04:38,600
finish off the slides here first. One thing about this
不过我们先讲完所有的幻灯片。 首先是关于强制转换的，

1192
01:04:38,600 --> 01:04:41,800
casting, you can cast other things besides any object,
你可以强制转换任何类型，而不单单是 AnyObject。

1193
01:04:41,800 --> 01:04:45,270
okay. So you, for example, you can look at this slide later,
例如像幻灯片上所展示的，

1194
01:04:45,270 --> 01:04:48,010
but you could have a class that's a subclass of another
当你有一个子类的对象指向父类的指针的情况下，

1195
01:04:48,010 --> 01:04:51,740
class, okay? And you can try and cast using as to get
你可以将父类指针强制转换成子类的对象。

1196
01:04:51,740 --> 01:04:55,550
the subclass. You're not sure whether it's a subclass, but
虽然你没办法确定它是否是子类的对象，

1197
01:04:55,550 --> 01:04:58,550
you can cast and as will tell you whether it is, okay?
但是你可以通过强制转换的结果告诉你是否是其子类。

1198
01:04:58,550 --> 01:05:01,220
In this case, for example, if I have view controller
例如，我有一个UIViewController的变量，

1199
01:05:01,220 --> 01:05:03,720
the base class of our view controller, we can't say
但是我们没办法使用

1200
01:05:03,720 --> 01:05:06,890
vc.displayValue cuz this is a CalculatorViewController
vc.displayValue, 因为这个属性是属于 CalculatorViewController 的属性。

1201
01:05:06,890 --> 01:05:09,030
thing. But if I went and as'ed it, okay,
当时如果我进行强制转换的话，

1202
01:05:09,030 --> 01:05:12,800
if I took this VC and as'ed it to CalculatorViewController,
我将其强制转换成 CalculatorViewController 后，

1203
01:05:12,800 --> 01:05:16,470
now I could use displayValue. Okay, so as is for
我就可以使用 displayValue 这个属性了。 因此强制转换

1204
01:05:16,470 --> 01:05:18,400
more than just any object.
不单单是针对 AnyObject。

1205
01:05:18,400 --> 01:05:20,470
Okay, and yes, you can force with as!,
当然你也可以使用关键字 as! 来进行强制转换，

1206
01:05:20,470 --> 01:05:23,740
it'll crash if it can't do it. Assertions I'm not gonna talk
但是如果没办法进行强制转换的话， 你的程序会崩溃。 我不会在这里进行

1207
01:05:23,740 --> 01:05:26,240
about cuz we talked about it in the debugging section.
讲解断言， 因为我们将在调试的章节进行讲解。

1208
01:05:26,250 --> 01:05:29,850
You can look at the slide or the reading assignment to find
你可以查看幻灯片或者是阅读作业来查看

1209
01:05:29,850 --> 01:05:32,780
out more about assert. And that's it. So coming up on
更多的关于断言的信息。 记得周三来听

1210
01:05:32,790 --> 01:05:35,820
Wednesday I'm gonna start talking about custom drawing.
关于自定义绘制的课程。

1211
01:05:35,820 --> 01:05:38,160
On Friday we don't have a section for this week.
这周五， 我们没有课程。

1212
01:05:38,160 --> 01:05:40,960
And next Monday I'm gonna start talking about gestures,
下周我们我们开始讲解手势，

1213
01:05:40,960 --> 01:05:43,690
multi-touch gestures, okay, pinches and swipes and
多点触摸手势， 缩放以及滑动手势等，

1214
01:05:43,700 --> 01:05:45,860
stuff leading up to your assignment three,
并且该内容将会在你的第三次作业中用到，

1215
01:05:45,870 --> 01:05:48,130
which is you're gonna be doing a lot of drawing and
第三次作业包含了绘制、 多 MVC 以及其他的一些内容。

1216
01:05:48,130 --> 01:05:50,970
multiple MVCs and all that stuff. Your assignment this
这周的作业是

1217
01:05:50,970 --> 01:05:53,370
week is going to be the variables thing, okay?
关于变量的题目。

1218
01:05:53,370 --> 01:05:57,710
All right, so let's do that program var, okay?
接下来我们开始实现 program 属性吧。

1219
01:05:58,780 --> 01:06:02,110
Just gonna go back to our calculator here, all right,
重新回到计算器的程序，

1220
01:06:02,110 --> 01:06:07,080
and leave off exactly where we were. All right,
回到我们之前结束的地方。

1221
01:06:07,090 --> 01:06:08,690
so here's my controller, right here.
屏幕上显示的是我的 Controller。

1222
01:06:08,690 --> 01:06:10,890
I'm not gonna change my controller to do this.
目前我还不打算修改 Controller。

1223
01:06:10,890 --> 01:06:13,760
This is purely a brain thing, okay, here's my brain,
所需修改的都在 CalculatorBrain 中，

1224
01:06:13,760 --> 01:06:16,790
calculator brain. So I'm gonna add a new var.
这就是我的 CalculatorBrain 的代码， 我讲为其添加一个新的属性。

1225
01:06:16,800 --> 01:06:21,430
Let's put it I don't know, down here, okay?
我们加在那呢？ 就这里吧。

1226
01:06:21,430 --> 01:06:25,040
It's gonna be called program. It's AnyObject.
取名为 program， 类型为 AnyObject。

1227
01:06:25,040 --> 01:06:27,870
Now I'm gonna make it be AnyObject, but I'm also gonna
这里虽然我给他的类型为 AnyObject， 但是我同事也可以给他的类型

1228
01:06:27,870 --> 01:06:30,440
make it be a property list, cuz it's more useful.
为 PropertyList， 因为这个名字更加有可读性。

1229
01:06:30,440 --> 01:06:32,380
People can put it in as user defaults or whatever.
其他人可以将其存在 NSUserDefaults 或者是其他的地方。

1230
01:06:32,380 --> 01:06:35,880
So I'm gonna use a cool Swift thing called typealias.
这里就要用到一个 Swift 的一个特性， 叫做 typealias 。

1231
01:06:35,880 --> 01:06:38,720
typealias lets you create a type, a name type,
typealias 让你可以创建一个新的类型， 一个别名的类型，

1232
01:06:38,720 --> 01:06:41,450
that's exactly the same as some other type. So
它实际上与你绑定的类型是等价的。

1233
01:06:41,450 --> 01:06:45,890
I'm gonna create a type called PropertyList which equals
这里我讲创建一个叫做 PropertyList 的类型，并且它与

1234
01:06:45,890 --> 01:06:50,330
AnyObject. So PropertyList is now a type in Swift.
AnyObject 等价。 那么这样之后， PropertyList 就是一个新的类型了。

1235
01:06:50,330 --> 01:06:52,100
It's exactly the same thing as AnyObject.
但是其实他是跟 AnyObject 等价的。

1236
01:06:52,100 --> 01:06:55,000
Now why would I create this? That's because
为什么我要创建这个类型呢？

1237
01:06:55,000 --> 01:06:57,530
I'm gonna change this to say PropertyList. So
因为我希望这里的类型名称是 PropertyList。

1238
01:06:57,540 --> 01:07:00,240
I'm gonna cha, make the type of my program be PropertyList.
然后将 program 的类型修改成新的类型 PropertyList。

1239
01:07:00,240 --> 01:07:03,110
This tells anyone using my program that yeah,
这就等于告诉任何用 program 属性的人，

1240
01:07:03,110 --> 01:07:06,540
it's AnyObject but it's also a PropertyList, okay?
虽然他是一个 AnyObject 类型，但是它同样是 PropertyList 类型。

1241
01:07:06,550 --> 01:07:09,910
This is documentation. I'm essentially documenting here
这就是文档化， 我本来就是进行文档化

1242
01:07:09,920 --> 01:07:11,720
that this AnyObject is PropertyList.
即 AnyObject 改名为 PropertyList。

1243
01:07:11,720 --> 01:07:14,990
I could have also just put some comments in my code that
并且我也会将在代码中添加对应的注释

1244
01:07:14,990 --> 01:07:18,590
says it is, but this kind of really hammers home the po,
这是一个非常好的做法将 program 的

1245
01:07:18,590 --> 01:07:21,690
the point here that this is a PropertyList,
类型修改成 PropertyList。

1246
01:07:21,690 --> 01:07:25,860
okay? Now I'm gonna have my program here be computed,
现在我将要把我的运算表达式拿来计算。

1247
01:07:25,870 --> 01:07:29,530
okay? So I'm gonna do the get set thing, right? And
因此我要添加 get 和 set 方法。

1248
01:07:29,540 --> 01:07:33,140
so now I need to have my program internally,
因此我需要有一个内部的变量用来存储运算表达式，

1249
01:07:33,140 --> 01:07:35,870
I mean, internally store my program, so I'm actually gonna
我的意思是在该类中存储运算表达式的变量，

1250
01:07:35,880 --> 01:07:39,240
go up to the top and create another private var
因此我们回到程序的上端，添加一个新的私有属性

1251
01:07:39,250 --> 01:07:41,780
which is my internalProgram. And
名叫 internalProgram 的属性。

1252
01:07:41,780 --> 01:07:44,350
so I have to think about how I'm gonna store my program,
因此我需要考虑我应该如何存储我的运算表达式，

1253
01:07:44,350 --> 01:07:48,250
you know, all the operands and operations, internally. And
而我们知道所有的运算表达式都是有操作数和操作符组成的。

1254
01:07:48,250 --> 01:07:50,950
I'm just gonna store it to show you the power of
因此我只需要存储这些信息，并且用来展示 AnyObject 的强大。

1255
01:07:50,960 --> 01:07:56,760
AnyObject. I'm gonna store it as an array of AnyObject,
因此我这里用一个 AnyObject 的数组来存储这些信息。

1256
01:07:56,760 --> 01:08:01,530
okay? And the objects in that array are gonna be a double if
而数组中的元素可能是 Double 类型，当然是一个操作数的时候，

1257
01:08:01,530 --> 01:08:05,500
it's an operand or a string if it's an operation. So
可能是一个 String 类型，当它是一个操作符的时候。

1258
01:08:05,500 --> 01:08:08,410
I'm gonna have an array that has a mix of doubles and
因此我这里需要一个混合了 Double 和 String 类型的数组，

1259
01:08:08,410 --> 01:08:11,280
strings, okay, and that's gonna store my program.
用来存储的运算表达式。

1260
01:08:11,280 --> 01:08:14,010
I'm just gonna put operands in as doubles and I'm gonna put
我只需将操作数以 Double 的形式进行存储，

1261
01:08:14,010 --> 01:08:16,780
operations as strings. So that's another power of
将操作符以 String 的形式进行存储。 这里就能展示 AnyObject 的优势之一了。

1262
01:08:16,780 --> 01:08:20,180
AnyObject here. So how do I implement my internalProgram?
那么我应该如何使用 internalProgram 呢？

1263
01:08:20,190 --> 01:08:24,690
Real simple, okay. When I set an operand, I'm just gonna
非常简单， 当我调用 setOperand 的时候，

1264
01:08:24,690 --> 01:08:29,830
tell my internalProgram append that operand, oops.
我只需将对应的操作数添加到 internalProgram 中即可。

1265
01:08:29,830 --> 01:08:32,430
Okay, now normally this is AnyObject.
当时这里使用的是 AnyObject 类型做为数组元素的类型，

1266
01:08:32,430 --> 01:08:36,900
Operand is a double, that's a struct. That normally wouldn't
但是操作数是一个 Double 的类型， 它是一个Struct。 原本应该是没办法

1267
01:08:36,900 --> 01:08:39,800
work, but the bridging, the Objective-C bridging,
存入数组中的， 但是苹果的桥接技术做到了， 就是与 Objective-C 的桥接技术

1268
01:08:39,810 --> 01:08:43,340
will make this work. Okay, I told you everywhere in the UI
使的操作数能存入数组中。 我之前在讲 UI 的时候也提到过，

1269
01:08:43,340 --> 01:08:45,310
where you have this compatibility,
Swift 与 Objective-C 是具有非常好的兼容性。

1270
01:08:45,310 --> 01:08:46,840
it's gonna automatically bridge.
因为苹果内部已经实现了自动的桥接技术。

1271
01:08:46,850 --> 01:08:48,980
I don't, look, I don't have to do anything or say anything.
而我不需要做任何事情。

1272
01:08:48,980 --> 01:08:52,150
It just automatically always bridges when necessary.
当它需要兼容的时候，就会自动进行桥接。

1273
01:08:52,150 --> 01:08:54,220
Okay, similar down here in my operation.
当然，下面的操作符也是同样的处理方式。

1274
01:08:54,220 --> 01:08:57,150
When someone performs an operation, I'm just gonna tell
当有人调用 performOperation 时， 我只需将它加到

1275
01:08:57,160 --> 01:09:00,420
my internalProgram append the symbol for this operation.
运算表达式的 internalProgram 变量即可。

1276
01:09:00,430 --> 01:09:02,990
Okay, that's a string. Again, a struct but
但是操作符是一个 String， 同样是一个 Struct 类型，

1277
01:09:03,000 --> 01:09:06,200
it's automatically bridged to NSString and
但是它会自动使用桥接技术， 转换成 NSString 类型，

1278
01:09:06,200 --> 01:09:09,330
thus can be an AnyObject. Okay, that's it, that's
所能能将其转换成 AnyObject 类型。

1279
01:09:09,340 --> 01:09:11,470
the entire implementation of my internalProgram.
这就是关于所有的 internalProgram 属性的使用。

1280
01:09:11,470 --> 01:09:14,770
I'm just remembering every operand and operation.
我只需记住没有一个操作数和操作符即可。

1281
01:09:14,770 --> 01:09:19,610
So now I'm just gonna return that internalProgram here,
接着在这里我只需返回 internalProgram 即可，

1282
01:09:19,610 --> 01:09:20,980
okay, to be the program.
用来返回 prgram。

1283
01:09:20,980 --> 01:09:24,150
Now you might be freaking out, whoa, you're returning
也许你会吓到， 为什么你这里

1284
01:09:24,150 --> 01:09:27,780
your internal data structure here to a public caller. But
要讲私有的数据返回给公用的接口？

1285
01:09:27,790 --> 01:09:32,560
what kind of type is an array? A value type. And
但是数组具体是什么类型？ 是一个值传递的类型。

1286
01:09:32,560 --> 01:09:36,830
what happens when you return a value type? It gets copied.
那么一个值传递类型的数据作为返回值会出现什么情况？ 会用它的副本进行返回。

1287
01:09:36,830 --> 01:09:40,360
Okay, so I'm not returning a pointer to my internal data
因此我不是返回一个指向内部数据的指针对象，

1288
01:09:40,370 --> 01:09:44,370
structure here, I'm returning a copy. Okay, that's, again,
而是返回它的一个副本而已。

1289
01:09:44,370 --> 01:09:47,100
a cool thing about having these things be value types.
由此可以看出一个值传递类型的优点。

1290
01:09:47,110 --> 01:09:50,470
All right, so now we have to do the set. So someone can now
那么解析来我们实现一下 set 方法。 目前别人能获得

1291
01:09:50,480 --> 01:09:53,180
get my program and they can give it back to me later and
我的运算表达式， 并且之后会将其重新交给我，

1292
01:09:53,180 --> 01:09:55,580
I have to run it. Okay, so how am I gonna do that?
而我必须重新运算一遍这个表达式。 那么我该如何实现呢？

1293
01:09:55,580 --> 01:09:59,380
Well, when someone sets my program, first I'm gonna clear
首先，当有人需要重新给我运算表达式的时候， 我先要清空

1294
01:09:59,390 --> 01:10:03,190
whatever's in my program. So you, you guys probably
当前的运算表达式。 而在之后的作业中，

1295
01:10:03,190 --> 01:10:07,490
implemented something like this for your homework, but
也可能会遇到类似的题目。

1296
01:10:07,490 --> 01:10:11,660
I'm gonna, see clear my accumulator. I'm gonna say
而这里我需要重置操作数， 将

1297
01:10:11,660 --> 01:10:15,070
that I have no pending binary operation. And I'm gonna
pending 属性有置为空并且

1298
01:10:15,070 --> 01:10:18,640
clear my internalProgram that I currently have out.
将当前存储的操作数和操作符都清空。

1299
01:10:18,640 --> 01:10:22,240
Actually I'll just removeAll items from my internalProgram.
事实上我只需将数组中的所有元素移除即可。

1300
01:10:22,240 --> 01:10:25,540
Okay, so that's clear cuz I'm running a new program, so
这就是我的清空方法， 然后我需要重新运算新的运算表达式，

1301
01:10:25,540 --> 01:10:26,880
I wanna clear all my stuff out.
但是在此之前我必须重置我的所有属性。

1302
01:10:26,880 --> 01:10:29,910
Right, make sense? Now I'm just gonna say if
而我现在只需判断

1303
01:10:29,920 --> 01:10:34,180
the program they get me, gave me is an array of op,
他们给我的新的运算表达式是否是一个操作数和操作符的数组，

1304
01:10:34,190 --> 01:10:37,050
operands and operations, so I'm gonna
而我这里只需要

1305
01:10:37,060 --> 01:10:41,560
say if I can let arrayOfOps equal this newValue that they
通过 if let arrayOfOps = newValue as? [AnyObject]

1306
01:10:41,560 --> 01:10:46,230
just gave me as an array of AnyObject, which it has to be.
的语句进行判断，并且该判断必须要成立。

1307
01:10:46,230 --> 01:10:48,930
If it's not that, I can just ignore this. Someone gave
如果它不成立的话，我就直接忽视它即可。

1308
01:10:48,930 --> 01:10:51,600
me a program which was not one that I gave out, so I'm
例如有人给了一个运算表达式给我， 但是却不是从我这里给出的，

1309
01:10:51,600 --> 01:10:54,540
ignoring it, cuz it's gotta be an array of AnyObject or
那么我讲忽视它， 因此它必须是一个 AnyObject 的数组，

1310
01:10:54,540 --> 01:10:57,610
I can't figure out what it is. So if it is, now I'm just
否则我无法判断里面具体是什么内容。 那么如果它是一个数组的话，

1311
01:10:57,610 --> 01:10:59,840
gonna go look through at all the ops in there,
我只需遍历所有在数组中

1312
01:10:59,850 --> 01:11:03,550
all the operations and operands. Okay, an arrayOfOps.
的操作数和操作符。

1313
01:11:03,550 --> 01:11:06,620
Okay, that's how we loop through an array, right, for
这就是我们常用的遍历数组的方式———— for in 的方式。

1314
01:11:06,620 --> 01:11:09,950
in. And for each one I'm gonna check and see what it is.
对于每一个元素我都进行检查看看它是什么。

1315
01:11:09,960 --> 01:11:12,460
Now what type, if I can Alt-click on this,
那么这里的 op 是什么类型呢？ 如果我通过 Alt + 左键点击op的话，

1316
01:11:12,460 --> 01:11:16,090
what type is this gonna be? >> AnyObject?
会显示什么类型呢？ [学生回答] AnyObject ?

1317
01:11:16,100 --> 01:11:16,930
>> AnyObject, exactly.
对的， 就是 AnyObject 类型。

1318
01:11:16,930 --> 01:11:20,530
See, AnyObject. So I can't do anything with AnyObject,
看见没， 就是 AnyObject 类型。 但是我们还没办法处理 AnyObject 类型，

1319
01:11:20,530 --> 01:11:23,100
so I have to try and see if I can make it something else.
因此我必须尝试看看能否做一些其他的事情。

1320
01:11:23,100 --> 01:11:27,400
So I'm gonna first try and make it be an operand by
首先我先进行判断它是否是一个 Double 类型的

1321
01:11:27,410 --> 01:11:32,010
saying op as a Double, okay? So if I get to here,
操作数？ 如果运行到这一行的话，

1322
01:11:32,010 --> 01:11:32,140
then this op,
那么这个 op 在数组中的变量

1323
01:11:32,140 --> 01:11:36,380
the next thing I looked in the array was a Double. Excellent,
就是一个 Double 类型的数据。

1324
01:11:36,380 --> 01:11:39,680
then I can just say setOperand to be that operand, okay,
那么接下来我就可以调用  setOperand 来进行进行处理这个操作数。

1325
01:11:39,690 --> 01:11:43,090
cuz I'm running the program. So I'm just gonna replay,
因为我这里是重新运行运算表达式， 所以我这里只需对

1326
01:11:43,090 --> 01:11:46,290
basically, my operands and operations. Otherwise,
操作数和操作符进行一遍运算。

1327
01:11:46,290 --> 01:11:49,990
if I can let, let's say operation = op as a String,
另一方面， 我通过 let operation = op as? String 来进行判断是否是操作数，

1328
01:11:50,000 --> 01:11:54,770
okay, then I'm going to perform that operation.
如果是操作数的话， 这里就调用一下 performOperation 的方法。

1329
01:11:58,540 --> 01:12:03,070
Okay? Done, okay, very simple, I've done it.
实现好了，非常简单吧。

1330
01:12:03,080 --> 01:12:05,810
Now you're going to have to really make sure you
那么目前你必须保证你是理解

1331
01:12:05,810 --> 01:12:09,450
understand this, because you need to enhance this for your
这些代码的， 因为你需要对该项目进行完善， 在作业中

1332
01:12:09,450 --> 01:12:12,750
assignment number two. Because you're gonna have variables,
用到类似的方法。 例如你将用到变量，

1333
01:12:12,750 --> 01:12:15,490
you're gonna have to deal with here too. You're gonna have
而你也需要处理这些变量。

1334
01:12:15,490 --> 01:12:19,020
variables in your program, not just operands and operations.
你需要处理的你的运算表达式， 而不是仅仅的操作数与操作符。

1335
01:12:19,020 --> 01:12:20,520
Now, let's see this thing in action.
那么看我们来实际运行看看。

1336
01:12:20,530 --> 01:12:22,760
We've got this code and we wanna make sure it works, so
我们写好了这些代码，我们需要确认是否它实现成功了，

1337
01:12:22,760 --> 01:12:25,930
let's put something in our UI that actually checks
我们需要在界面上添加一些东西来检查这段

1338
01:12:25,930 --> 01:12:26,700
this program business.
程序的正确性。

1339
01:12:26,700 --> 01:12:27,800
So, I'm gonna go back to my storyboard.
所以我们先回到我们的 Storyboard。

1340
01:12:27,800 --> 01:12:31,600
I'm gonna steal a couple of buttons here. I'm gonna make
我这里只需要修改一些按钮。

1341
01:12:31,600 --> 01:12:34,540
this be the save button and this be the restore button.
将这个按钮变成保存的按钮， 而下面一个按钮变成重新运算的按钮。

1342
01:12:34,540 --> 01:12:37,670
So I'm gonna have the save button, save the program, and
而保存的按钮用来保存之前的运算表达式，

1343
01:12:37,680 --> 01:12:40,940
then I have the restore button, restore the program.
重新运算的按钮用来重新运算之前的的运算表达式。

1344
01:12:40,950 --> 01:12:43,980
Okay, so you can see how it would look like to use that.
这样你就可以想象我们应该如何使用它了。

1345
01:12:43,980 --> 01:12:48,120
So these are not operation buttons anymore, so
而这两个按钮不在是操作符的按钮，

1346
01:12:48,120 --> 01:12:51,990
I'm gonna disconnect using right-click,
所以我需要通过右键来断开之前链接的事件，

1347
01:12:51,990 --> 01:12:54,590
all these perform operations. Okay,
所有这两个按钮的事件回调。

1348
01:12:54,590 --> 01:12:59,760
then I'm gonna wire these up. Let's make some room. Wire up,
解析来我要重新绑定事件的回调。 让我们让 Xcode 多一些控件来进行绑定。

1349
01:12:59,770 --> 01:13:05,200
down here. All right, so I'm gonna wire up save first.
那么我们先对保存按钮进行绑定事件的回调方法。

1350
01:13:05,200 --> 01:13:09,440
Put it right here. I'll call it save. It's an action.
将其拖拉到这里， 并且给方法取名为 save, 设置它是 Action。

1351
01:13:09,440 --> 01:13:09,640
It doesn't need an arg,
该方法不需要参数，

1352
01:13:09,640 --> 01:13:11,980
I don't need the sender this time, this is the first time
这次回调方法不需要一个参数， 这是我们第一次遇到不需要

1353
01:13:11,980 --> 01:13:14,410
we've seen where we don't need the sender. Okay,
参数的回调方法。

1354
01:13:14,410 --> 01:13:16,810
at least the first time not in your homework.
至少不是在你的作业中的第一次遇到。

1355
01:13:16,820 --> 01:13:22,020
And here's restore. And restore is also an action, and
同样的方法拉一个 restore 的事件回调， 同样是一个 Action，

1356
01:13:22,020 --> 01:13:25,260
it doesn't need an argument either. Here we go, there's
同样不需要一个参数。 这样就可以了，

1357
01:13:25,260 --> 01:13:28,530
save and restore. Okay, how am I gonna implement this? Well,
这就是我们的两个按钮的事件回调的方法。 那么我具体该如何实现呢？

1358
01:13:28,530 --> 01:13:32,100
I need the saved program, so I'm gonna have a savedProgram.
我需要保存之前的运算表达式， 所以我需要一个 saveProgram 的属性。

1359
01:13:32,100 --> 01:13:34,560
Its type could be any object, but
它的类型可以是 AnyObject， 但是

1360
01:13:34,570 --> 01:13:40,000
I'm actually gonna have it be CalculatorBrain.PropertyList.
这里更建议使用 CalculatorBrain.PropertyList 的类型。

1361
01:13:40,010 --> 01:13:42,970
Just to be clear to myself, this is a property list, and
首先你的自己清楚， 这是一个 PropertyList，

1362
01:13:42,980 --> 01:13:45,810
if I wanted to save this into NFC or default,
并且如果我我想将其存入 NSUserDefaults 的话，

1363
01:13:45,810 --> 01:13:49,150
I could. Okay, but I'm not going to, but I could.
我也能做到。  但是目前我还没算这样做， 即使我是能做到的。

1364
01:13:49,150 --> 01:13:51,150
All right, so how do I save?
那么我该如何实现 save 方法呢？

1365
01:13:51,150 --> 01:13:52,780
And I'm gonna make this optional because,
在此之前我应该将其变成一个 Optional 的类型，

1366
01:13:52,790 --> 01:13:54,420
of course I might not have hit save yet.
因为我刚开始可能没有保存过预算表达式。

1367
01:13:54,420 --> 01:13:55,090
So it's gonna start out as nil,
那么它的初始值应该是 nil .

1368
01:13:55,090 --> 01:13:57,850
as soon as I hit save it's gonna have a value. All right,
直到我触发 save 方法之后， 它才会有值。

1369
01:13:57,860 --> 01:14:02,430
so how do I save? Well, I'm just gonna say that this
那么我们该如何实现 save 方法呢？ 我应该

1370
01:14:02,430 --> 01:14:06,630
savedProgram = the calculators brain.program.
将 CalculatorBrain 中的 program 保存到 savedProgram 即可。

1371
01:14:06,630 --> 01:14:10,400
Okay, that's gonna store it in there, really good, you see?
只需在这里保存即可， 非常简单， 对吧？

1372
01:14:10,400 --> 01:14:15,910
How about restore? Okay, well, if I have a savedProgram
那么 restore 方法又该如何实现呢？ 如果 savedProgram 不为

1373
01:14:15,910 --> 01:14:21,080
!= nil, then I'm just gonna set the brains.program
空的话， 我将其重新传递给 CalculatorBrain。

1374
01:14:21,080 --> 01:14:23,710
= savedProgram. Okay, I have to unwrap it,
并且我这里需要强制解析它，

1375
01:14:23,720 --> 01:14:27,350
cuz it's an optional. And then I'd better update my display
因为他是一个 Optional 的类型。 然后我需要更新我

1376
01:14:27,350 --> 01:14:30,390
value now because the brain is gonna have a different result.
显示的值， 因为 CalculatorBrain 可能重新运算后会有不同的结果。

1377
01:14:30,390 --> 01:14:34,420
It's got a new program, it's gonna have a different result,
因为它获得了一个新的运算表达式， 所以它可能会运算跟当前显示不同的结果。

1378
01:14:34,430 --> 01:14:36,230
got it? Okay now, this code,
看明白这段代码了吗？

1379
01:14:36,230 --> 01:14:38,330
you don't need this in your assignment. This is,
这些代码应该在作业中用不到。

1380
01:14:38,330 --> 01:14:41,160
I'm only putting this here just to demonstrate program.
这只是我放在这里的实例代码而已。

1381
01:14:41,170 --> 01:14:43,170
You will need the other code in CalculatorBrain,
你需要在 CalculatorBrain 中的其他代码，

1382
01:14:43,170 --> 01:14:46,340
but you will not need this code. Okay, let's go ahead and
而不需要这段代码。 那么让我重新

1383
01:14:46,340 --> 01:14:55,310
run this. All right,
运行这个程序。

1384
01:14:55,310 --> 01:14:57,780
here we go, make this a little bigger. All right,
将模拟器变大一点。

1385
01:14:57,780 --> 01:15:00,620
let's rotate so that our restore button looks better.
将模拟器进行旋转一下， 这样我们的 restore 按钮看起来更美观一点。

1386
01:15:00,620 --> 01:15:03,290
All right, here we go. So let's put a program in here,
我们先输入一个表达式，

1387
01:15:03,290 --> 01:15:10,060
4 x 5 + 1 =. Okay, that's 21. Okay, let's save that program,
输入 4 乘以 5 加上 1 等于。 答案是21. 然后点击保存按钮。

1388
01:15:10,060 --> 01:15:14,930
now let's do pi square root. Okay, that's good, + 8 =,
然后在点击π、 根号、 加号、 8 等一些其他按钮。

1389
01:15:14,930 --> 01:15:18,740
something like that. Now let's restore. What should happen to
然后点击 restore 按钮， 那么会发生什么呢？

1390
01:15:18,740 --> 01:15:21,540
our display when I restore? >> 21.
如果我点击 restore 后。 [学生回答] 21.

1391
01:15:21,540 --> 01:15:22,370
>> 21 cuz it's gonna rerun
答案是21， 因为我们重新运算了之前的

1392
01:15:22,370 --> 01:15:27,440
that program. And sure enough, there it is.
运算表达式。 这个是可以肯定的。

1393
01:15:27,450 --> 01:15:30,480
Okay, 14 divided by 7=, restore. Okay, we, we,
14 除以 7 等于， 点击restore。 看见没？

1394
01:15:30,480 --> 01:15:34,450
we've run that program, and that's the result in there, so
我们重新运算了之前的表达式， 所以它的结果就展示在这里了。

1395
01:15:34,450 --> 01:15:38,890
we can say x 2 =. Okay, we could save
而我们可以针对结果继续运算， 如乘以 2 等于之类的。

1396
01:15:38,890 --> 01:15:42,530
it again. Okay, 47 divide 8 =, and now when we restore,
当然我们重新保存新的表达式。 继续输入 47 除以 8 等于， 然后我们在点击 restore 按钮，

1397
01:15:42,530 --> 01:15:45,300
we'll get 42, which is the meaning of life, the universe,
我们还是能拿到 42，也就是说无论从哪个角度来

1398
01:15:45,300 --> 01:15:47,900
and everything, and so we're done, okay. So
说， 我们都完成了想要的功能。

1399
01:15:47,900 --> 01:15:52,500
get that program to code into your app, okay.
将这部分代码拷贝到你们的程序中，

1400
01:15:52,500 --> 01:15:55,570
You'll need to add that to your assignment one, and then
你将会在作业一种需要用到这些代码，

1401
01:15:55,570 --> 01:15:58,610
I will be publishing, I might actually publish assignment
当然我会将这些代码发布出来， 我也会将作业二

1402
01:15:58,610 --> 01:16:01,110
two before Wednesday, okay. It goes out on Wednesday,
在周三前发布出来。 作业将在周三发布，

1403
01:16:01,110 --> 01:16:03,280
due the next Wednesday. But for those of you who want to
直到下周三为止。 当然对于那些想先多学一点

1404
01:16:03,280 --> 01:16:05,580
start a little early, cuz you know everything you need to
的同学们， 因为已经学会了一些

1405
01:16:05,580 --> 01:16:08,650
know now to do assignment two as well, okay. So
你们也可以提前做作业二。

1406
01:16:08,650 --> 01:16:13,060
I'll probably publish that earlier, maybe tomorrow.
我会尽早将其发布出来，也可能是明天。

1407
01:16:13,060 --> 01:16:13,520
>> For more,
想获得更多信息，

1408
01:16:13,530 --> 01:16:13,560
please visit us at stanford.edu.
请访问我们的网站 stanford.edu。

